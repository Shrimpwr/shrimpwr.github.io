<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.0.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  <title>MIT 6.828 Lab2 - 5hr1m9wr</title>

  

  
    <meta name="description" content="Notes of MIT 6.828 Lab2">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.828 Lab2">
<meta property="og:url" content="https://moe.lovmayoi.top/2022/03/14/mit-6-828-lab2/index.html">
<meta property="og:site_name" content="5hr1m9wr">
<meta property="og:description" content="Notes of MIT 6.828 Lab2">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-14T13:01:52.000Z">
<meta property="article:modified_time" content="2022-04-04T12:07:16.679Z">
<meta property="article:author" content="5hr1m9wr">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="5hr1m9wr" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/images/my_favicon.ico">
  

  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    


<header class="header">

<div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.2/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://cdn.jsdelivr.net/gh/cdn-x/placeholder@1.0.1/image/2659360.svg';"></a><a class="title" href="/"><div class="main">5hr1m9wr</div><div class="sub cap">Random Thoughts.</div></a></div>
<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/friends/">友人</a><a class="nav-item" href="/about/">关于</a></nav></header>

<div class="widgets">

<div class="widget-wrap single" id="toc"><div class="widget-header cap dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-1-Physical-Page-Management"><span class="toc-text">Part 1: Physical Page Management</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#physical-page-allocator"><span class="toc-text">physical page allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise-1"><span class="toc-text">Exercise 1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-2-Virtual-Memory"><span class="toc-text">Part 2: Virtual Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-Linear-and-Physical-Addresses"><span class="toc-text">Virtual, Linear, and Physical Addresses</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Question-1"><span class="toc-text">Question 1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Counting"><span class="toc-text">Reference Counting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Page-Table-Management"><span class="toc-text">Page Table Management</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise-4"><span class="toc-text">Exercise 4</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-3-Kernel-Address-Space"><span class="toc-text">Part 3: Kernel Address Space</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Permissions-and-Fault-Isolation"><span class="toc-text">Permissions and Fault Isolation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Initializing-the-Kernel-Address-Space"><span class="toc-text">Initializing the Kernel Address Space</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise-5"><span class="toc-text">Exercise 5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Question-2"><span class="toc-text">Question 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Challenge"><span class="toc-text">Challenge</span></a></li></ol></li></ol></li></ol></div></div></div>


</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" title="RSS" href="/atom.xml" rel="noopener noreferrer"><img alt="svgImg" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjBweCIgeT0iMHB4Igp3aWR0aD0iMzIiIGhlaWdodD0iMzIiCnZpZXdCb3g9IjAgMCAxNzEgMTcxIgpzdHlsZT0iIGZpbGw6IzAwMDAwMDsiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIuNDA3OTcsMi40MDc5Nykgc2NhbGUoMC45NzIsMC45NzIpIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSJub25lIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJub25lIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIGZvbnQtZmFtaWx5PSJub25lIiBmb250LXdlaWdodD0ibm9uZSIgZm9udC1zaXplPSJub25lIiB0ZXh0LWFuY2hvcj0ibm9uZSIgc3R5bGU9Im1peC1ibGVuZC1tb2RlOiBub3JtYWwiPjxnIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSI1IiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMTQ0LjI4MTI1LDE0NC4yODEyNWgtMjEuMzc1YzAsLTUzLjA2MzQ0IC00My4xMjQwNiwtOTYuMTg3NSAtOTYuMTg3NSwtOTYuMTg3NXYtMjEuMzc1YzY0LjkyNjU2LDAgMTE3LjU2MjUsNTIuNjM1OTQgMTE3LjU2MjUsMTE3LjU2MjV6TTEwNi44NzUsMTQ0LjI4MTI1aC0yMS4zNzVjMCwtMzIuNDM2NTYgLTI2LjM0NDY5LC01OC43ODEyNSAtNTguNzgxMjUsLTU4Ljc4MTI1di0yMS4zNzVjNDQuMjQ2MjUsMCA4MC4xNTYyNSwzNS45MSA4MC4xNTYyNSw4MC4xNTYyNXpNNTguNzgxMjUsMTI4LjI1YzAsOC44NTM4MSAtNy4xNzc0NCwxNi4wMzEyNSAtMTYuMDMxMjUsMTYuMDMxMjVjLTguODUzODEsMCAtMTYuMDMxMjUsLTcuMTc3NDQgLTE2LjAzMTI1LC0xNi4wMzEyNWMwLC04Ljg1MzgxIDcuMTc3NDQsLTE2LjAzMTI1IDE2LjAzMTI1LC0xNi4wMzEyNWM4Ljg1MzgxLDAgMTYuMDMxMjUsNy4xNzc0NCAxNi4wMzEyNSwxNi4wMzEyNXoiPjwvcGF0aD48L2c+PHBhdGggZD0iTTAsMTcxLjk5ODA5di0xNzEuOTk4MDloMTcxLjk5ODA5djE3MS45OTgwOXoiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWpvaW49Im1pdGVyIj48L3BhdGg+PGcgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiPjxwYXRoIGQ9Ik0yNi43MTg3NSwyNi43MTg3NXYyMS4zNzVjNTMuMDYzNDQsMCA5Ni4xODc1LDQzLjEyNDA2IDk2LjE4NzUsOTYuMTg3NWgyMS4zNzVjMCwtNjQuOTI2NTYgLTUyLjYzNTk0LC0xMTcuNTYyNSAtMTE3LjU2MjUsLTExNy41NjI1ek0yNi43MTg3NSw2NC4xMjV2MjEuMzc1YzMyLjQzNjU2LDAgNTguNzgxMjUsMjYuMzQ0NjkgNTguNzgxMjUsNTguNzgxMjVoMjEuMzc1YzAsLTQ0LjI0NjI1IC0zNS45MSwtODAuMTU2MjUgLTgwLjE1NjI1LC04MC4xNTYyNXpNNDIuNzUsMTEyLjIxODc1Yy04Ljg1MzgxLDAgLTE2LjAzMTI1LDcuMTc3NDQgLTE2LjAzMTI1LDE2LjAzMTI1YzAsOC44NTM4MSA3LjE3NzQ0LDE2LjAzMTI1IDE2LjAzMTI1LDE2LjAzMTI1YzguODUzODEsMCAxNi4wMzEyNSwtNy4xNzc0NCAxNi4wMzEyNSwtMTYuMDMxMjVjMCwtOC44NTM4MSAtNy4xNzc0NCwtMTYuMDMxMjUgLTE2LjAzMTI1LC0xNi4wMzEyNXoiPjwvcGF0aD48L2c+PHBhdGggZD0iIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciI+PC9wYXRoPjxwYXRoIGQ9IiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiPjwvcGF0aD48cGF0aCBkPSIiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWpvaW49Im1pdGVyIj48L3BhdGg+PC9nPjwvZz48L3N2Zz4="/></a><a class="social" title="GitHub" href="https://github.com/Shrimpwr" target="_blank" rel="external nofollow noopener noreferrer"><img alt="svgImg" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHg9IjBweCIgeT0iMHB4Igp3aWR0aD0iNTAiIGhlaWdodD0iNTAiCnZpZXdCb3g9IjAgMCAxNzEgMTcxIgpzdHlsZT0iIGZpbGw6IzAwMDAwMDsiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQuNzI5OTUsNC43Mjk5NSkgc2NhbGUoMC45NDUsMC45NDUpIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSJub25lIiBzdHJva2UtbGluZWNhcD0iYnV0dCIgc3Ryb2tlLWxpbmVqb2luPSJub25lIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHN0cm9rZS1kYXNoYXJyYXk9IiIgc3Ryb2tlLWRhc2hvZmZzZXQ9IjAiIGZvbnQtZmFtaWx5PSJub25lIiBmb250LXdlaWdodD0ibm9uZSIgZm9udC1zaXplPSJub25lIiB0ZXh0LWFuY2hvcj0ibm9uZSIgc3R5bGU9Im1peC1ibGVuZC1tb2RlOiBub3JtYWwiPjxnIGlkPSJvcmlnaW5hbC1pY29uIDEiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIxMCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHBhdGggZD0iTTYuODQsODUuNWMwLC00My4zNzI0NCAzNS4yODQxNCwtNzguNjYgNzguNjYsLTc4LjY2YzQzLjM3NTg2LDAgNzguNjYsMzUuMjg3NTYgNzguNjYsNzguNjZjMCwzNC43NjA4OCAtMjIuNjc0Niw2NC4zMDk2OCAtNTQuMDA1MjIsNzQuNjc5MTJjLTIuNDMxNjIsLTEuMDQ2NTIgLTQuMTM0NzgsLTMuNDY0NDYgLTQuMTM0NzgsLTYuMjc5MTJ2LTE4LjQ2OGMwLC05LjIzNCAtOC4yMDgsLTIyLjU3MiAtMTcuMSwtMjIuNTcydi0wLjEwNjAyYzE5LjAwNDk0LC0wLjc0ODk4IDMxLjE2MzA0LC03LjE2ODMyIDM2Ljg1NzM0LC0xNy4wMTEwOGMxMi42ODEzNiwwLjA2MTU2IDIzLjgyNzE0LDEuMjg1OTIgMzAuMzY2MTgsMi4zMzI0NGMwLjE5ODM2LC0xLjExNDkyIDAuMzY5MzYsLTIuMjQwMSAwLjUxNjQyLC0zLjM3NTU0Yy02LjQzOTg2LC0xLjAyNiAtMTcuMTA2ODQsLTIuMTk5MDYgLTI5LjIzNDE2LC0yLjM1NjM4YzAuNDM3NzYsLTEuMDg0MTQgMC44MDcxMiwtMi4yMDI0OCAxLjExMTUsLTMuMzUxNmMxMi4yNTcyOCwtMC42NTMyMiAyMi44NzI5NiwtMC4xNjc1OCAyOC41ODc3OCwwLjMwNDM4YzAuMDYxNTYsLTEuMTM4ODYgMC4xNjc1OCwtMi4yNjQwNCAwLjE3NDQyLC0zLjQxNjU4Yy01LjczNTM0LC0wLjQ2NTEyIC0xNi4wOTExLC0wLjkzNzA4IC0yOC4wNTc2OCwtMC4zNDg4NGMwLjIyMjMsLTEuNTY2MzYgMC4zNzYyLC0zLjE2MzUgMC4zNzYyLC00LjgxODc4YzAuMzQyLC02LjE1NiAtMS43MSwtMTEuOTcgLTUuNDcyLC0xNy4xYzEuNzEsLTUuNDcyIDQuNDQ2LC0xNy43ODQgLTAuNjg0LC0yMi41NzJjLTkuMjM0LDAgLTE1LjczMiw0LjQ0NiAtMTguODEsNy4xODJjLTUuNDcyLC0yLjM5NCAtMTEuOTcsLTMuNzYyIC0xOS4xNTIsLTMuNzYyYy03LjE4MiwwIC0xMy42OCwxLjM2OCAtMTkuNDkwNTgsMy43NjU0MmMtMy4wNzgsLTIuNzM2IC05LjU3NiwtNy4xODIgLTE4LjgxLC03LjE4MmMtNC43ODgsNC40NDYgLTIuMzk0LDE2Ljc1OCAtMC42ODQsMjIuNTcyYy0zLjc2Miw1LjEzIC01LjgxNCwxMS4yODYgLTUuODE0LDE3LjFjMCwxLjgxOTQ0IDAuMTc0NDIsMy41NjcwNiAwLjQ0NDYsNS4yNzcwNmMtMTEuNjk5ODIsLTAuNTQzNzggLTIxLjc4MTk4LC0wLjA4MjA4IC0yNy40MjE1NiwwLjM3OTYyYzAuMDEzNjgsMS4xNDkxMiAwLjEwNjAyLDIuMjgxMTQgMC4xNzQ0MiwzLjQxNjU4YzUuNjI5MzIsLTAuNDY1MTIgMTUuOTkxOTIsLTAuOTQwNSAyNy45OTk1NCwtMC4zMzE3NGMwLjI4MDQ0LDAuOTkxOCAwLjYxMjE4LDEuOTU5NjYgMC45OTUyMiwyLjkwMzU4Yy0xMS45NzY4NCwwLjIyOTE0IC0yMi4zOTQxNiwxLjQyOTU2IC0yOC41Mzk5LDIuNDQxODhjMC4xNDcwNiwxLjEzMjAyIDAuMzE4MDYsMi4yNTcyIDAuNTE2NDIsMy4zNzU1NGM2LjIyNzgyLC0xLjAzMjg0IDE3LjE0MTA0LC0yLjI3NDMgMjkuNjc1MzQsLTIuNDE3OTRjNS43NjYxMiw5Ljk0ODc4IDE4LjE0OTk0LDE2LjM5MjA2IDM3LjUzNDUsMTcuMDE0NXYwLjA4NTVjLTQuNjIwNDIsMCAtOS4wNDI0OCwzLjYxMTUyIC0xMi4yMzY3Niw4LjM2MTljLTIuNzQyODQsMS40NzA2IC03LjMwMTcsMS44OTgxIC0xNS44MDcyNCwxLjg5ODFjLTUuNDcyLDAgLTguNTUsLTMuMDc4IC0xMS42MjgsLTYuODRjLTIuNzM2LC0zLjc2MiAtNy4xODIsLTYuNDk4IC05LjIzNCwtNi44NGMtMi4wNTIsMCAtMi43MzYsMS4wMjYgLTEuNzEsMS43MWM2LjE1Niw0LjEwNCA3LjE4MiwxMS42MjggOS41NzYsMTYuMDc0YzIuMDUyLDQuMTA0IDYuNDk4LDYuMTU2IDExLjYyOCw2LjE1NmMyLjA1MiwwIDEyLjMxMiwwIDEyLjMxMiwwYzAuMDQ3ODgsLTAuMDEwMjYgMC4wOTIzNCwtMC4wMjA1MiAwLjE0MDIyLC0wLjAzNDJjLTAuMDg1NSwwLjcxMTM2IC0wLjE0MDIyLDEuNDEyNDYgLTAuMTQwMjIsMi4wODYydjE4LjQ2OGMwLDIuODE0NjYgLTEuNzAzMTYsNS4yMzI2IC00LjEzNDc4LDYuMjc5MTJjLTMxLjMzMDYyLC0xMC4zNjk0NCAtNTQuMDA1MjIsLTM5LjkxODI0IC01NC4wMDUyMiwtNzQuNjc5MTJ6Ij48L3BhdGg+PC9nPjxwYXRoIGQ9Ik0wLDE3MS45OTgwOXYtMTcxLjk5ODA5aDE3MS45OTgwOXYxNzEuOTk4MDl6IiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciI+PC9wYXRoPjxnIGlkPSJvcmlnaW5hbC1pY29uIiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciI+PHBhdGggZD0iTTYwLjg0NTIyLDE2MC4xNzkxMmMyLjQzMTYyLC0xLjA0NjUyIDQuMTM0NzgsLTMuNDY0NDYgNC4xMzQ3OCwtNi4yNzkxMnYtMTguNDY4YzAsLTAuNjczNzQgMC4wNTQ3MiwtMS4zNzQ4NCAwLjE0MDIyLC0yLjA4NjJjLTAuMDQ3ODgsMC4wMTM2OCAtMC4wOTIzNCwwLjAyMzk0IC0wLjE0MDIyLDAuMDM0MmMwLDAgLTEwLjI2LDAgLTEyLjMxMiwwYy01LjEzLDAgLTkuNTc2LC0yLjA1MiAtMTEuNjI4LC02LjE1NmMtMi4zOTQsLTQuNDQ2IC0zLjQyLC0xMS45NyAtOS41NzYsLTE2LjA3NGMtMS4wMjYsLTAuNjg0IC0wLjM0MiwtMS43MSAxLjcxLC0xLjcxYzIuMDUyLDAuMzQyIDYuNDk4LDMuMDc4IDkuMjM0LDYuODRjMy4wNzgsMy43NjIgNi4xNTYsNi44NCAxMS42MjgsNi44NGM4LjUwNTU0LDAgMTMuMDY0NCwtMC40Mjc1IDE1LjgwNzI0LC0xLjg5ODFjMy4xOTQyOCwtNC43NTAzOCA3LjYxNjM0LC04LjM2MTkgMTIuMjM2NzYsLTguMzYxOXYtMC4wODU1Yy0xOS4zODQ1NiwtMC42MjI0NCAtMzEuNzY4MzgsLTcuMDY1NzIgLTM3LjUzNDUsLTE3LjAxNDVjLTEyLjUzNDMsMC4xNDM2NCAtMjMuNDQ3NTIsMS4zODUxIC0yOS42NzUzNCwyLjQxNzk0Yy0wLjE5ODM2LC0xLjExODM0IC0wLjM2OTM2LC0yLjI0MzUyIC0wLjUxNjQyLC0zLjM3NTU0YzYuMTQ1NzQsLTEuMDEyMzIgMTYuNTYzMDYsLTIuMjEyNzQgMjguNTM5OSwtMi40NDE4OGMtMC4zODMwNCwtMC45NDM5MiAtMC43MTQ3OCwtMS45MTE3OCAtMC45OTUyMiwtMi45MDM1OGMtMTIuMDA3NjIsLTAuNjA4NzYgLTIyLjM3MDIyLC0wLjEzMzM4IC0yNy45OTk1NCwwLjMzMTc0Yy0wLjA2ODQsLTEuMTM1NDQgLTAuMTYwNzQsLTIuMjY3NDYgLTAuMTc0NDIsLTMuNDE2NThjNS42Mzk1OCwtMC40NjE3IDE1LjcyMTc0LC0wLjkyMzQgMjcuNDIxNTYsLTAuMzc5NjJjLTAuMjcwMTgsLTEuNzEgLTAuNDQ0NiwtMy40NTc2MiAtMC40NDQ2LC01LjI3NzA2YzAsLTUuODE0IDIuMDUyLC0xMS45NyA1LjgxNCwtMTcuMWMtMS43MSwtNS44MTQgLTQuMTA0LC0xOC4xMjYgMC42ODQsLTIyLjU3MmM5LjIzNCwwIDE1LjczMiw0LjQ0NiAxOC44MSw3LjE4MmM1LjgxMDU4LC0yLjM5NzQyIDEyLjMwODU4LC0zLjc2NTQyIDE5LjQ5MDU4LC0zLjc2NTQyYzcuMTgyLDAgMTMuNjgsMS4zNjggMTkuMTUyLDMuNzYyYzMuMDc4LC0yLjczNiA5LjU3NiwtNy4xODIgMTguODEsLTcuMTgyYzUuMTMsNC43ODggMi4zOTQsMTcuMSAwLjY4NCwyMi41NzJjMy43NjIsNS4xMyA1LjgxNCwxMC45NDQgNS40NzIsMTcuMWMwLDEuNjU1MjggLTAuMTUzOSwzLjI1MjQyIC0wLjM3NjIsNC44MTg3OGMxMS45NjY1OCwtMC41ODgyNCAyMi4zMjIzNCwtMC4xMTYyOCAyOC4wNTc2OCwwLjM0ODg0Yy0wLjAwNjg0LDEuMTUyNTQgLTAuMTEyODYsMi4yNzc3MiAtMC4xNzQ0MiwzLjQxNjU4Yy01LjcxNDgyLC0wLjQ3MTk2IC0xNi4zMzA1LC0wLjk1NzYgLTI4LjU4Nzc4LC0wLjMwNDM4Yy0wLjMwNDM4LDEuMTQ5MTIgLTAuNjczNzQsMi4yNjc0NiAtMS4xMTE1LDMuMzUxNmMxMi4xMjczMiwwLjE1NzMyIDIyLjc5NDMsMS4zMzAzOCAyOS4yMzQxNiwyLjM1NjM4Yy0wLjE0NzA2LDEuMTM1NDQgLTAuMzE4MDYsMi4yNjA2MiAtMC41MTY0MiwzLjM3NTU0Yy02LjUzOTA0LC0xLjA0NjUyIC0xNy42ODQ4MiwtMi4yNzA4OCAtMzAuMzY2MTgsLTIuMzMyNDRjLTUuNjk0Myw5Ljg0Mjc2IC0xNy44NTI0LDE2LjI2MjEgLTM2Ljg1NzM0LDE3LjAxMTA4djAuMTA2MDJjOC44OTIsMCAxNy4xLDEzLjMzOCAxNy4xLDIyLjU3MnYxOC40NjhjMCwyLjgxNDY2IDEuNzAzMTYsNS4yMzI2IDQuMTM0NzgsNi4yNzkxMmMzMS4zMzA2MiwtMTAuMzY5NDQgNTQuMDA1MjIsLTM5LjkxODI0IDU0LjAwNTIyLC03NC42NzkxMmMwLC00My4zNzI0NCAtMzUuMjg0MTQsLTc4LjY2IC03OC42NiwtNzguNjZjLTQzLjM3NTg2LDAgLTc4LjY2LDM1LjI4NzU2IC03OC42Niw3OC42NmMwLDM0Ljc2MDg4IDIyLjY3NDYsNjQuMzA5NjggNTQuMDA1MjIsNzQuNjc5MTJ6Ij48L3BhdGg+PC9nPjxwYXRoIGQ9IiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiPjwvcGF0aD48cGF0aCBkPSIiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWpvaW49Im1pdGVyIj48L3BhdGg+PHBhdGggZD0iIiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgc3Ryb2tlLWxpbmVqb2luPSJtaXRlciI+PC9wYXRoPjxwYXRoIGQ9IiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIHN0cm9rZS1saW5lam9pbj0ibWl0ZXIiPjwvcGF0aD48cGF0aCBkPSIiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBzdHJva2UtbGluZWpvaW49Im1pdGVyIj48L3BhdGg+PC9nPjwvZz48L3N2Zz4="/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      

<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/notes/">notes</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-03-14T13:01:52.000Z">2022-03-14</time></div></div>

<article class='content md post'>
<h1 class="article-title"><span>MIT 6.828 Lab2</span></h1><p class="post-excerpt">Notes of MIT 6.828 Lab2</p>
<h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><h3 id="physical-page-allocator"><a href="#physical-page-allocator" class="headerlink" title="physical page allocator"></a>physical page allocator</h3><p>Write the physical page allocator. It keeps track of which pages are free with a linked list of struct PageInfo objects (which, unlike xv6, are not embedded in the free pages themselves), each corresponding to a physical page.</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><p>Implement the following functions.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init() (only up to the call to check_page_free_list(1))</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>
<p><code>boot_alloc()</code> is a simple physical allocator which is used only while kernel is setting up its virtual memory system.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">boot_alloc</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;    <span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">    <span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line">    <span class="comment">// which points to the end of the kernel&#x27;s bss segment:</span></span><br><span class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">    <span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">    <span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">        nextfree = <span class="built_in">ROUNDUP</span>((<span class="keyword">char</span> *) end, PGSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span></span><br><span class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">    <span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)nextfree - KERNBASE &gt; (npages * PGSIZE - n)) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = nextfree;</span><br><span class="line">    nextfree = <span class="built_in">ROUNDUP</span>(nextfree + n, PGSIZE);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In <code>mem_init()</code>, add code to allocate an array of npages <code>struct PageInfo</code>s and store it in <code>pages</code>. The kernel uses this array to keep track of physical pages.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) <span class="built_in">boot_alloc</span>(npages * <span class="built_in"><span class="keyword">sizeof</span></span>(struct PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="built_in"><span class="keyword">sizeof</span></span>(struct PageInfo));</span><br></pre></td></tr></table></figure>
<p><code>page_init()</code> is used to initialize the page structure and memory free list.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page 0</span></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">    pages[<span class="number">0</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the rest of base memory</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO hole</span></span><br><span class="line">    <span class="keyword">for</span> (i = IOPHYSMEM &gt;&gt; <span class="number">12</span>; i &lt; EXTPHYSMEM &gt;&gt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">    <span class="keyword">physaddr_t</span> end_of_kern = <span class="built_in">PADDR</span>(<span class="built_in">ROUNDUP</span>((<span class="keyword">char</span> *) end, PGSIZE));</span><br><span class="line">    <span class="keyword">int</span> size_of_table = <span class="built_in">ROUNDUP</span>(npages * <span class="built_in"><span class="keyword">sizeof</span></span>(struct PageInfo), PGSIZE) &gt;&gt; <span class="number">12</span>; </span><br><span class="line">    <span class="keyword">int</span> end_of_inuse_page = (end_of_kern &gt;&gt; <span class="number">12</span>) + <span class="number">1</span> + size_of_table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in use extended memory, including kernel, kernpgdir and pages array</span></span><br><span class="line">    <span class="keyword">for</span> (i = EXTPHYSMEM &gt;&gt; <span class="number">12</span>; i &lt; end_of_inuse_page; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free extended memory</span></span><br><span class="line">    <span class="keyword">for</span> (i = end_of_inuse_page; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page_alloc()</code> is used to allocate a physical page from the free list.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">victim</span> =</span> page_free_list;</span><br><span class="line"></span><br><span class="line">    page_free_list = victim-&gt;pp_link;</span><br><span class="line">    victim-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">page2kva</span>(victim), <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page_free()</code> is used to free a physical page and put it into the free list. We need to check whether the page is still in use (using <code>pp_ref</code>) or the page has already been freed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">    <span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;pp_ref)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;reference count non zero&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;pp_link)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;double free detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pp-&gt;pp_link = page_free_list;</span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>In x86 terminology, a virtual address consists of a segment selector and an offset within the segment. A linear address is what you get after segment translation but before page translation. A physical address is what you finally get after both segment and page translation and what ultimately goes out on the hardware bus to your RAM.</p>
<p>In out inplementation, the <code>GDT</code> installed in <code>boot/boot.s</code> actually disabled segment translation by setting all segment base addresses to 0 and limits to 0xffffffff. Hence the “selector” has no effect and the linear address always equals the offset of the virtual address.</p>
<p>In the previous lab, we installed a simple page table to map only 4MB of physical memory at <code>0x00100000</code> to the virtual space starting at <code>0xf0100000</code>. This is sufficient for the kernel to start up, but we will need to set up the complete kernel space in the following part.</p>
<h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><div class="table-container">
<table>
<thead>
<tr>
<th>C type</th>
<th>Address type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T*</code></td>
<td>Virtual</td>
</tr>
<tr>
<td><code>uintptr_t</code></td>
<td>Virtual</td>
</tr>
<tr>
<td><code>physaddr_t</code></td>
<td>Physical</td>
</tr>
</tbody>
</table>
</div>
<p>Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value = return_a_pointer();</span><br><span class="line">*value = 10;</span><br><span class="line">x = (mystery_t) value;</span><br></pre></td></tr></table></figure>
<p>The answer is <code>uintptr_t</code>.</p>
<h3 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h3><p>We keep a count of the number of references to each physical page in the <code>pp_ref</code> field of the <code>struct PageInfo</code> corresponding to the physical page.  </p>
<p>When this count goes to zero for a physical page, that page can be freed because it is no longer used. In general, this count should be equal to the number of times the physical page appears below <code>UTOP</code> in all page tables (the mappings above <code>UTOP</code> are mostly set up at boot time by the kernel and should never be freed, so there’s no need to reference count them).  </p>
<p>We’ll also use it to keep track of the number of pointers we keep to the page directory pages and, in turn, of the number of references the page directories have to page table pages.</p>
<h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>Implement the following functions</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()</span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()</span><br><span class="line">page_insert()</span><br></pre></td></tr></table></figure>
<p><code>pgdir_walk()</code> tries to find the relevant page table entry in the page directory for a given virtual address. If <code>create</code> equals to 1, it will create the corresponding page table if it does not exist. The function returns a pointer to the found page table entry.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">pgdir_walk</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pde_t</span> pde = pgdir[<span class="built_in">PDX</span>(va)];</span><br><span class="line">    <span class="keyword">pte_t</span> *pgtbl_ptr;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pde == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (create == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">new_pgtbl_info</span> =</span> <span class="built_in">page_alloc</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (new_pgtbl_info == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        new_pgtbl_info-&gt;pp_ref++;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">page2kva</span>(new_pgtbl_info), <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">        pde = pgdir[<span class="built_in">PDX</span>(va)] = <span class="built_in">page2pa</span>(new_pgtbl_info) | PTE_W | PTE_P | PTE_U;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pgtbl_ptr = (<span class="keyword">pte_t</span> *) <span class="built_in">KADDR</span>(<span class="built_in">PTE_ADDR</span>(pde));</span><br><span class="line">    <span class="keyword">return</span> (pgtbl_ptr + <span class="built_in">PTX</span>(va));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>boot_map_region()</code> maps [va, va+size) of virtual address space to physical [pa, pa+size) in the page table rooted at pgdir. It’s intended to set up the static mappings above <code>UTOP</code>, so <code>pp_ref</code> field of the mapped pages isn’t changed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mind the alignment</span></span><br><span class="line">    <span class="keyword">int</span> cnt = size / PGSIZE;</span><br><span class="line">    <span class="keyword">if</span> (size % PGSIZE) cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte_ptr = <span class="built_in">pgdir_walk</span>(pgdir, (<span class="keyword">const</span> <span class="keyword">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">        (*pte_ptr) = pa | perm | PTE_P;</span><br><span class="line">        va += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page_lookup()</code> returns the page mapped at virtual address ‘va’. If <code>pte_store</code> is not zero, then we store in it the address of the pte for this page.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr = <span class="built_in">pgdir_walk</span>(pgdir, va, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_ptr != <span class="literal">NULL</span> &amp;&amp; (*pte_ptr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>)</span><br><span class="line">            (*pte_store) = pte_ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pa2page</span>(<span class="built_in">PTE_ADDR</span>(*pte_ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page_remove()</code> unmaps the page at virtual address ‘va’. It needs to call <code>page_decref()</code> and <code>tlb_invalidate()</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> =</span> <span class="built_in">page_lookup</span>(pgdir, va, &amp;pte_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*pte_ptr) != <span class="number">0</span>) &#123;</span><br><span class="line">            (*pte_ptr) = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">tlb_invalidate</span>(pgdir, va);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">page_decref</span>(page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page_insert()</code> maps the physical page <code>pp</code> at virtual address <code>va</code>. If there is already a page mapped at <code>va</code>, it will be removed using <code>page_remove()</code>. And <code>pp_ref</code> should be incremented it the insertion succeeds.<br>There is a corner case which requires attention. If the same <code>pp</code> is re-inserted at the same virtual address in the same pgdir, if we call <code>page_remove()</code> before incrementing the <code>pp_ref</code>, the page may be freed because of the call to <code>page_decref()</code> in <code>page_remove()</code>.<br>By incrementing <code>pp_ref</code> before calling <code>page_remove()</code>, we can elegantly handle the corner case.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr = <span class="built_in">pgdir_walk</span>(pgdir, va, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment pp_ref before page_remove() to handle corner case</span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*pte_ptr) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">page_remove</span>(pgdir, va);</span><br><span class="line"></span><br><span class="line">    (*pte_ptr) = <span class="built_in">page2pa</span>(pp) | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>The virtual space layout is like this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                Permissions</span></span><br><span class="line"><span class="comment"> *                                                    kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4 Gig --------&gt;  +------------------------------+</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     |   Remapped Physical Memory   | RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span></span><br><span class="line"><span class="comment"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span></span><br><span class="line"><span class="comment"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span></span><br><span class="line"><span class="comment"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span></span><br><span class="line"><span class="comment"> *                     |          RO PAGES            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span></span><br><span class="line"><span class="comment"> *                     |           RO ENVS            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span></span><br><span class="line"><span class="comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebff000</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span></span><br><span class="line"><span class="comment"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span></span><br><span class="line"><span class="comment"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebfd000</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span></span><br><span class="line"><span class="comment"> *                     |     Program Data &amp; Heap      |</span></span><br><span class="line"><span class="comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |  User STAB Data (optional)   |                 PTSIZE</span></span><br><span class="line"><span class="comment"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *    0 ------------&gt;  +------------------------------+                 --+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>We use the permission bits in the page table to control access and implement page-level isolation.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Page Directory Entry     Page Table Entry      Combined Protection</span><br><span class="line">U/S          R/W         U/S      R/W          U/S         R/W</span><br><span class="line"></span><br><span class="line">S-0          R-0         S-0      R-0           S           x</span><br><span class="line">S-0          R-0         S-0      W-1           S           x</span><br><span class="line">S-0          R-0         U-1      R-0           S           x</span><br><span class="line">S-0          R-0         U-1      W-1           S           x</span><br><span class="line">S-0          W-1         S-0      R-0           S           x</span><br><span class="line">S-0          W-1         S-0      W-1           S           x</span><br><span class="line">S-0          W-1         U-1      R-0           S           x</span><br><span class="line">S-0          W-1         U-1      W-1           S           x</span><br><span class="line">U-1          R-0         S-0      R-0           S           x</span><br><span class="line">U-1          R-0         S-0      W-1           S           x</span><br><span class="line">U-1          R-0         U-1      R-0           U           R</span><br><span class="line">U-1          R-0         U-1      W-1           U           R</span><br><span class="line">U-1          W-1         S-0      R-0           S           x</span><br><span class="line">U-1          W-1         S-0      W-1           S           x</span><br><span class="line">U-1          W-1         U-1      R-0           U           R</span><br><span class="line">U-1          W-1         U-1      W-1           U           W</span><br></pre></td></tr></table></figure>
<h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>Now we use <code>boot_map_region</code> which we just implemented to initialize the kernel address space above <code>UTOP</code>.</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>Fill in the missing code in mem_init() after the call to check_page().</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="built_in">boot_map_region</span>(kern_pgdir, UPAGES, PTSIZE, <span class="built_in">PADDR</span>(pages), PTE_U);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="built_in">boot_map_region</span>(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, <span class="built_in">PADDR</span>(bootstack), PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="built_in">boot_map_region</span>(kern_pgdir, KERNBASE, <span class="number">0x0fffffff</span>, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>
<h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h4><ul>
<li>What entries (rows) in the page directory have been filled in at this point?</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Entry</th>
<th>Base Virtual Address</th>
<th>Points to (logically)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1023</td>
<td>0xffc00000</td>
<td>Page table for top 4MB of phys memory</td>
</tr>
<tr>
<td>1022</td>
<td>0xff800000</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>960</td>
<td>0xf0000000</td>
<td>Page table for bottom 4MB of phys memory</td>
</tr>
<tr>
<td>959</td>
<td>0xefff8000</td>
<td>Page table for kernel stack</td>
</tr>
<tr>
<td>957</td>
<td>0xef400000</td>
<td>PD itself as a page table</td>
</tr>
<tr>
<td>956</td>
<td>0xef000000</td>
<td>Page table of pages mapped at UPAGES</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>2</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>1</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>0</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p>
<ul>
<li>Page level protection. The U/S bit in PTEs.</li>
</ul>
</li>
<li><p>What is the maximum amount of physical memory that this operating system can support? Why?</p>
<ul>
<li>2GB. npages = 524288, max amount of physical memory = npages * 4KB = 2GB.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));</span><br></pre></td></tr></table></figure>
</li>
<li><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p>
<ul>
<li>Size of <code>pages</code> = npages * sizeof(struct PageInfo);</li>
<li>Size of <code>kern_pgdir</code> = PGSIZE</li>
<li>Total size of all page tables = PGSIZE * 1K</li>
</ul>
</li>
<li><p>Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p>
<ul>
<li><code>jmp *%eax</code> does the trasition. Because we set up a <code>entry_pgdir</code> to map virtual addresses [KERNBASE, KERNBASE+4MB) to physical addresses [0, 4MB). Because we need kernel to run at the virtual space above <code>KERNBASE</code>, leaving the virtual space below for user process.</li>
</ul>
</li>
</ul>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>Extend the JOS kernel monitor with commands <code>showmappings</code>, <code>setpermbits</code> and <code>dumpmem</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>*</span></span><br><span class="line"><span class="function"><span class="title">pageperm2str</span><span class="params">(<span class="keyword">pte_t</span> pte, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *str[] = &#123; <span class="string">&quot;_________SR_&quot;</span>, <span class="string">&quot;AVLGPDACTUWP&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">        buf[i] = str[pte &gt;&gt; (<span class="number">11</span> - i) &amp; <span class="number">0x1</span>][i];</span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">str2pageperm</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pri = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*buf != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (*buf++) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">                pri |= PTE_P;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                pri |= PTE_W;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">                pri |= PTE_U;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                pri |= PTE_PWT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                pri |= PTE_PCD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                pri |= PTE_A;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                pri |= PTE_D;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">                pri |= PTE_G;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_showmappings</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> &amp;&amp; argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Wrong number of arguments.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Usage: showmappings begin_vaddr [end_vaddr]\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin, end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pptr;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">ROUNDDOWN</span>((<span class="keyword">uint32_t</span>)<span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>), PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        end = begin;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        end = <span class="built_in">ROUNDDOWN</span>((<span class="keyword">uint32_t</span>)<span class="built_in">strtol</span>(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>), PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (begin &gt; <span class="number">0xf7ffffff</span> || end &gt; <span class="number">0xf7ffffff</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual Address out of range.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%8s\t%8s\t%12s\n&quot;</span>, <span class="string">&quot;VA&quot;</span>, <span class="string">&quot;PA&quot;</span>, <span class="string">&quot;PERMBITS&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (; begin &lt;= end; begin += PGSIZE) &#123;</span><br><span class="line">        pp = <span class="built_in">page_lookup</span>(kern_pgdir, (<span class="keyword">void</span> *)begin, &amp;pptr);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">pageperm2str</span>(*pptr, buf);</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t%08x\t%12s\n&quot;</span>, begin, <span class="built_in">page2pa</span>(pp), buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t%8s\t%12s\n&quot;</span>, begin, <span class="string">&quot;none&quot;</span>, <span class="string">&quot;none&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_setpermbits</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Wrong number of arguments.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Usage: setpermbits +/-permbits vaddr\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pptr, pte;</span><br><span class="line">    <span class="keyword">char</span> buf_old[<span class="number">15</span>], buf_new[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">       begin = <span class="built_in">ROUNDDOWN</span>((<span class="keyword">uint32_t</span>) <span class="built_in">strtol</span>(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>), PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (begin &gt; <span class="number">0xf7ffffff</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual Address out of range.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pp = <span class="built_in">page_lookup</span>(kern_pgdir, (<span class="keyword">void</span> *)begin, &amp;pptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;No mpping exists.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pte = *pptr;</span><br><span class="line">    <span class="keyword">if</span> (*argv[<span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span>) </span><br><span class="line">        *pptr |= <span class="built_in">str2pageperm</span>(argv[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*argv[<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        *pptr &amp;= ~<span class="built_in">str2pageperm</span>(argv[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual\t\tPhysical\tOld Priority\tNew Priority\t\n&quot;</span>);</span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t%08x\t%12s\t%12s\n&quot;</span>, begin, <span class="built_in">page2pa</span>(pp), <span class="built_in">pageperm2str</span>(pte, buf_old), <span class="built_in">pageperm2str</span>(*pptr, buf_new));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_dumpmem</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Wrong number of arguments.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Usage: dumpmem -p/v begin_addr end_addr\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin, end;</span><br><span class="line"></span><br><span class="line">       begin = (<span class="keyword">uint32_t</span>) <span class="built_in">strtol</span>(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">       end = (<span class="keyword">uint32_t</span>) <span class="built_in">strtol</span>(argv[<span class="number">3</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">PGNUM</span>(begin) &gt;= npages) || (<span class="built_in">PGNUM</span>(end) &gt;= npages)) &#123;</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;Physical address out of range.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = (<span class="keyword">uint32_t</span>) <span class="built_in">KADDR</span>(begin);</span><br><span class="line">        end = (<span class="keyword">uint32_t</span>) <span class="built_in">KADDR</span>(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= <span class="number">0xf7ffffff</span> || end &gt;= <span class="number">0xf7ffffff</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual address out of range.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual\t\tPhysical\tMemory Contents\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">pte_t</span> *pptr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t&quot;</span>, begin);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">page_lookup</span>(kern_pgdir, (<span class="keyword">void</span> *) begin, &amp;pptr) == <span class="literal">NULL</span> || *pptr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;No Mapping\n&quot;</span>);</span><br><span class="line">            begin += PGSIZE - begin % PGSIZE;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t&quot;</span>, <span class="built_in">PTE_ADDR</span>(*pptr) | <span class="built_in">PGOFF</span>(begin));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++, begin++)</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;%02x &quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) begin);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></section></div>


</article>

<div class="related-wrap reveal" id="read-next"><section class="header cap theme"><span>接下来阅读</span></section><section class="body fs14"><a id="next" href="/2022/02/28/mit-6-828-hw1/">MIT 6.828 HW1 Boot xv6<span class="note">较早</span></a><div class="line"></div><a id="prev" href="/2022/03/30/mit-6-828-hw2/">MIT 6.828 HW2 shell<span class="note">较新</span></a></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/categories">分类</a><a href="/tags">标签</a><a href="/archives">归档</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friends">友链</a><a target="_blank" rel="noopener" href="https://twitter.com/5hr1m9wr_">Twitter</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about">关于</a></div></div><div class="text"><p>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
<p>本站由 <a href="https://moe.lovmayoi.top/">@5hr1m9wr</a> 创建，使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.7.0" title="v1.7.0">Stellar</a> 作为主题。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.7.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@6/swiper-bundle.min.css","js":"https://unpkg.com/swiper@6/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://cdn.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti/umd/heti.min.css","js":"https://unpkg.com/heti/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->

  
    <div class="cnzzstats"><script type="text/javascript" src="https://s9.cnzz.com/z_stat.php?id=1278945960&web_id=1278945960"></script></div>
  


  </div>
</body>
</html>
