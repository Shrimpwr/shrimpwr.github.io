<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>5hr1m9wr</title>
  
  <subtitle>Random Thoughts.</subtitle>
  <link href="https://moe.lovmayoi.top/atom.xml" rel="self"/>
  
  <link href="https://moe.lovmayoi.top/"/>
  <updated>2022-02-23T09:59:18.785Z</updated>
  <id>https://moe.lovmayoi.top/</id>
  
  <author>
    <name>5hr1m9wr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT 6.828 Lab1</title>
    <link href="https://moe.lovmayoi.top/2022/02/04/mit-6-828-lab1/"/>
    <id>https://moe.lovmayoi.top/2022/02/04/mit-6-828-lab1/</id>
    <published>2022-02-04T11:47:36.000Z</published>
    <updated>2022-02-23T09:59:18.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>A PC’s physical address space is hard-wired to have the following general layout.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>The IBM PC starts with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code>, executing at physical address <code>0x000ffff0</code>, which is at the very top of the 64KB area reserved for the ROM BIOS.  </p><blockquote><p>In real mode (the mode that PC starts off in), address translation works according to the formula: physical address = 16 * segment + offset.</p></blockquote><p>The BIOS in a PC is “hard-wired” to the physical address range <code>0x000f0000-0x000fffff</code>, this design ensures that the BIOS always gets control of the machine first after power-up or any system restart.</p><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p>Generally, the BIOS performs the following tasks</p><ul><li>Sets up an IDT (Interrupt Descriptor Table，中断向量表)</li><li>Initializes various devices such as the VGA display</li><li>After initializing the PCI bus and all the important devices the BIOS knows about, it searches for a bootable device such as a floppy, hard drive, or CD-ROM. When it finds a bootable disk, the BIOS reads the <strong>boot loader</strong> from the disk and transfers control to it.</li></ul><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><h3 id="The-Boot-loader"><a href="#The-Boot-loader" class="headerlink" title="The Boot loader"></a>The Boot loader</h3><p>Floppy and hard disks for PCs are divided into 512 byte regions called sectors. The first sector of a bootable disk is called the <em>boot sector</em>.  </p><p>When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses <code>0x7c00</code> through <code>0x7dff</code>, and then uses a <code>jmp</code> instruction to set the <code>CS:IP</code> to <code>0000:7c00</code>, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs.  </p><p>The boot loader performs the following functions:</p><ul><li><p>First, switch the processor from real mode to <strong>32-bit protected mode</strong>, because it is only in this mode that software can access all the memory above 1MB in the processor’s physical address space. The boot loader sets the <code>$CR0_PE_ON</code> bit in register <code>cr0</code> and loads the GDT.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # and segment translation that makes virtual addresses </span><br><span class="line">  # identical to their physical addresses, so that the </span><br><span class="line">  # effective memory map does not change during the switch.</span><br><span class="line">  lgdt    gdtdesc</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  </span><br><span class="line">  # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">  # Switches processor into 32-bit mode.</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL                                # null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)       # code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)             # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>GDT (Global Descriptor Table)</strong> is a significant structure in protected mode.<br>Typically, we access memory address by <code>selector:offset</code>. In real mode,   a selector is an paragraph number of physical memory. In protected mode, a selector value is an intex into a descriptor table, and each segment is assigned an entry in a descriptor table.<br>The whole system has one Global Descriptor Table. Its entry address and limit of length are hold in register <code>GDTR</code>. During protected mode initialization, we have to use the instruction <code>lgdt</code> to assign <code>GDTR</code> with a new value.<br>The structure of GDT entry is as the following. It specifies the base and limit address of the segment and access properties (that’s why it’s called <strong>protected</strong> mode).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struc gdt_entry_struct</span><br><span class="line">  limit_low:    resb 2</span><br><span class="line">  base_low:     resb 2</span><br><span class="line">  base_middle:  resb 1</span><br><span class="line">  access:       resb 1</span><br><span class="line">  granularity:  resb 1</span><br><span class="line">  base_high:    resb 1</span><br><span class="line">end struc </span><br></pre></td></tr></table></figure></blockquote><ul><li><p>Second, the boot loader reads the <strong>kernel</strong> from the hard disk by directly accessing the IDE disk device registers via the x86’s special I/O instructions.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">  ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">  eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">  <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">  <span class="comment">// note: does not return!</span></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><ul><li>After this instruction <code>ljmp    $PROT_MODE_CSEG, $protcseg</code>, the processor starts to work in 32-bit mode. The cause is that <code>ljmp</code> loads the value of <code>$PROT_MODE_CSEG</code> into <code>CS</code>, and the value of <code>$protcseg</code> into <code>EIP</code>. After that, the processor will use the value of <code>CS</code> as an index of GDT to find the corresponding segment descriptor.</li><li>The last instruction of the boot loader is <code>call   *0x10018</code>, the first instruction of the kernel is <code>movw   $0x1234,0x472</code>.</li><li>The first instruction of the kernel is in file <code>kern/entry.s</code>, at address <code>0x10000c</code>.</li><li>The boot loader reads the <code>ELFHDR-&gt;e_phnum</code> from kernel’s elf header, and uses the <code>ph-&gt;p_memsz</code> to decide how many sectors to read per segment.</li></ul><h3 id="Loading-the-kernel"><a href="#Loading-the-kernel" class="headerlink" title="Loading the kernel"></a>Loading the kernel</h3><p>We can examine the ELF section headers like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ objdump -h obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001acd  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br></pre></td></tr></table></figure><ul><li>LMA(load address): The load address of a section is the memory address at which that section should be loaded into memory.</li><li>VMA(link address): The link address of a section is the memory address from which the section expects to execute.<br>Typically, the link and load addresses are the same.</li></ul><p>The boot loader users the ELF program headers to decide how to load the sections. The program headers specify which parts of the ELF object to load into memory and the destination address each should occupy.<br>We can inspect the program header like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ objdump -x obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line">obj/kern/kernel</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x00007e20 memsz 0x00007e20 flags r-x</span><br><span class="line">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12</span><br><span class="line">         filesz 0x0000b6a8 memsz 0x0000b6a8 flags rw-</span><br><span class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</span><br><span class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</span><br></pre></td></tr></table></figure><p><code>vaddr</code> means virtual addresss and <code>paddr</code> means physical address.</p><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>We can change the link address of boot loader by modifying option <code>-Ttext</code> boot/Makefrag. For example, <code>0x7d00</code>.  </p><p>After changing this, boot loader will break at <code>ljmp    $PROT_MODE_CSEG, $protcseg</code> because the boot loader is executing from an address (<code>0x7c00</code>) that is different from the address from which it expects to execute (<code>0x7d00</code>).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">[   0:7c2d] =&gt; 0x7c2d:  ljmp   $0x8,$0x7d32</span><br></pre></td></tr></table></figure><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel.  </p><p>The two results are different because the boot loader loads the kernel into that address.</p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>As we inspected above, there was a (rather large) disparity between the kernel’s link address (as printed by objdump) and its load address.  </p><p>Operating system kernels often like to be linked and run at very high virtual address, such as 0xf0100000, in order to leave the lower part of the processor’s virtual address space for user programs to use.  </p><p>We use the processor’s memory management hardware to map virtual address 0xf0100000 (the link address at which the kernel code expects to run) to physical address 0x00100000 (where the boot loader loaded the kernel into physical memory).</p><p>For now, we’ll just map the first 4MB of physical memory, using the hand-written, statically-initialized page directory and page table in <code>kern/entrypgdir.c</code>.  </p><p>After <code>kern/entry.S</code> sets the <code>CR0_PG</code> flag, paging is enabled, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses. <code>entry_pgdir</code> translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000.</p><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>We can examine memory at <code>0x00100000</code> and at <code>0xf0100000</code> before and after the <code>movl %eax, %cr0</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) x/10gx 0x00100000</span><br><span class="line">0x100000:       0x000000001badb002      0x7205c766e4524ffe</span><br><span class="line">0x100010:       0x2000b81234000004      0xc0200fd8220f0011</span><br><span class="line">0x100020:       0xc0220f800100010d      0xbde0fff010002fb8</span><br><span class="line">0x100030:       0x110000bc00000000      0xfeeb0000006ce8f0</span><br><span class="line">0x100040:       0x56e58955fb1e0ff3      0xc3810000017ee853</span><br><span class="line">(gdb) x/10gx 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:  0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100020 &lt;entry+20&gt;:  0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100030 &lt;relocated+1&gt;:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100040 &lt;test_backtrace&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">(gdb) ni</span><br><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/10gx 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:  0x000000001badb002      0x7205c766e4524ffe</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x2000b81234000004      0xc0200fd8220f0011</span><br><span class="line">0xf0100020 &lt;entry+20&gt;:  0xc0220f800100010d      0xbde0fff010002fb8</span><br><span class="line">0xf0100030 &lt;relocated+1&gt;:       0x110000bc00000000      0xfeeb0000006ce8f0</span><br><span class="line">0xf0100040 &lt;test_backtrace&gt;:    0x56e58955fb1e0ff3      0xc3810000017ee853</span><br></pre></td></tr></table></figure><p>The first instruction that would fail if the mapping weren’t in place is <code>mov $relocated, %eax</code>.</p><h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>The formatted print function <code>int cprintf(const char *fmt, ...)</code> is implemented in <code>kern/printf.c</code>, which relys on <code>lib/printfmt.c</code> and <code>kern/console.c</code>.</p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>Complete the code of <code>vprintfmt</code> in <code>lib/printfmt.c</code> to print octal numbers using patterns of the form “%o”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (unsigned) octal</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">  <span class="comment">// Replace this with your code.</span></span><br><span class="line">  num = getuint(&amp;ap, lflag);</span><br><span class="line">  base = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><ol><li><p>The interface between <code>printf.c</code> and <code>console.c</code> is function <code>void cputchar(int c)</code> that <code>console.c</code> exports.<br><code>printf.c</code> calls it in <code>static void putch(int ch, int *cnt)</code>, and passes the pointer to <code>putch</code> as an argument to <code>vprintfmt((void*)putch, &amp;cnt, fmt, ap)</code> that is called in function <code>vcprintf</code>. And <code>vcprintf</code> is called by function <code>cprintf</code>.</p></li><li><p>The following code is in function <code>static void cga_putc(int c)</code>, which is used to output characters to CGA/VGA display.<br>The purpose of this piece of code is to deal with the situation where the position of the cursor exceeds the screen.<br><code>crt_pos</code> is the position of next character to be output, on the other hand, the position of the cursor. And <code>CRT_SIZE</code> = <code>CRT_ROWS</code> * <code>CRT_COLS</code>, so it means the maximum number of characters that can be displayed on the screen.<br>It moves all the characters on the screen upward by one column (using <code>memmove</code>) , and fills the last column with <code>0x0x00 | &#39; &#39;</code>, and ends by recalculating <code>crt_pos</code>.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What is the purpose of this?</span></span><br><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 Lab1.</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>让Hexo Blog支持Mathjax</title>
    <link href="https://moe.lovmayoi.top/2022/02/04/blog-add-mathjax/"/>
    <id>https://moe.lovmayoi.top/2022/02/04/blog-add-mathjax/</id>
    <published>2022-02-04T09:53:21.000Z</published>
    <updated>2022-02-04T14:59:13.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Add-themes-my-theme-layout-mathjax-ejs"><a href="#Add-themes-my-theme-layout-mathjax-ejs" class="headerlink" title="Add themes/*my_theme*/layout/mathjax.ejs"></a>Add <code>themes/*my_theme*/layout/mathjax.ejs</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.mathjax.enable)&#123; %&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      MathJax.Hub.Config(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">tex2jax</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">inlineMath</span>: [ [<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>], [<span class="string">&quot;\\(&quot;</span>,<span class="string">&quot;\\)&quot;</span>] ],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">processEscapes</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      MathJax.Hub.Config(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">tex2jax</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">skipTags</span>: [<span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;noscript&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;textarea&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>, <span class="string">&#x27;code&#x27;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      MathJax.Hub.Queue(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="keyword">var</span> all = MathJax.Hub.getAllJax(), i;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; all.length; i += <span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                  all[i].SourceElement().parentNode.className += <span class="string">&#x27; has-jax&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%- theme.mathjax.cdn %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="Add-this-to-config-yml"><a href="#Add-this-to-config-yml" class="headerlink" title="Add this to _config.yml"></a>Add this to <code>_config.yml</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><h4 id="Add-this-to-themes-my-theme-layout-post-ejs"><a href="#Add-this-to-themes-my-theme-layout-post-ejs" class="headerlink" title="Add this to themes/*my_theme*/layout/post.ejs"></a>Add this to <code>themes/*my_theme*/layout/post.ejs</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.mathjax == <span class="literal">true</span>)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(<span class="string">&#x27;mathjax&#x27;</span>) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="Enable-mathjax-in-post’s-header"><a href="#Enable-mathjax-in-post’s-header" class="headerlink" title="Enable mathjax in post’s header"></a>Enable mathjax in post’s header</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让Hexo Blog支持Mathjax</span><br><span class="line">date: 2022-02-04 17:53:21</span><br><span class="line">tags: [blog]</span><br><span class="line">categories: [notes]</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="Replace-the-renderer"><a href="#Replace-the-renderer" class="headerlink" title="Replace the renderer"></a>Replace the renderer</h4><p>如果之前有安装过<code>hexo-math</code>，还需要先卸载。<br>Hexo 默认的 Markdown 渲染器是<code>hexo-renderer-marked</code>，在解析$\LaTeX$语法的时候会和 Markdown 本身的语法符号冲突。<br>最直接的解决方法是换个渲染器，在这里我选择的是 <a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><script type="math/tex; mode=display">\LaTeX\ is\ supported\ now.</script><blockquote><p>参考文章：<br><a href="https://adores.cc/posts/62947.html">给Hexo主题添加LaTeX公式支持</a></p></blockquote>]]></content>
    
    
    <summary type="html">最近重新搭了一遍博客，使用的主题是Stella，感觉还挺对我审美的。然而这个主题本身不支持Mathjax，所以还得手动改一下。</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="blog" scheme="https://moe.lovmayoi.top/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>重启</title>
    <link href="https://moe.lovmayoi.top/2022/01/30/%E9%87%8D%E5%90%AF/"/>
    <id>https://moe.lovmayoi.top/2022/01/30/%E9%87%8D%E5%90%AF/</id>
    <published>2022-01-29T16:06:16.000Z</published>
    <updated>2022-02-04T14:59:06.416Z</updated>
    
    <content type="html"><![CDATA[<p>之后要完善的东西还挺多的，慢慢来吧。很长一段时间没写东西，以后可以多写点（</p>]]></content>
    
    
    <summary type="html">花了半天，姑且是把博客重新搭起来了。</summary>
    
    
    
    <category term="gossip" scheme="https://moe.lovmayoi.top/categories/gossip/"/>
    
    
    <category term="blog" scheme="https://moe.lovmayoi.top/tags/blog/"/>
    
  </entry>
  
</feed>
