<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>5hr1m9wr</title>
  
  <subtitle>Random Thoughts.</subtitle>
  <link href="https://moe.lovmayoi.top/atom.xml" rel="self"/>
  
  <link href="https://moe.lovmayoi.top/"/>
  <updated>2022-04-04T12:25:33.483Z</updated>
  <id>https://moe.lovmayoi.top/</id>
  
  <author>
    <name>5hr1m9wr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT 6.828 HW5 xv6 CPU alarm</title>
    <link href="https://moe.lovmayoi.top/2022/04/04/mit-6-828-hw5/"/>
    <id>https://moe.lovmayoi.top/2022/04/04/mit-6-828-hw5/</id>
    <published>2022-04-04T12:08:41.000Z</published>
    <updated>2022-04-04T12:25:33.483Z</updated>
    
    <content type="html"><![CDATA[<p>Add a new <code>alarm(interval, handler)</code> system call.<br>If an application calls <code>alarm(n, fn)</code>, then after every n ticks of CPU time that the program consumes, the kernel will cause application function <code>fn</code> to be called. When <code>fn</code> returns, the application will resume where it left off.</p><p>First, we modify the struct <code>proc</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  uint sz;                     <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pde_t</span>* pgdir;                <span class="comment">// Page table</span></span><br><span class="line">  <span class="keyword">char</span> *kstack;                <span class="comment">// Bottom of kernel stack for this process</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>        <span class="comment">// Trap frame for current syscall</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span>     <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="comment">// fields for alarm</span></span><br><span class="line">  <span class="keyword">int</span> alarmticks;</span><br><span class="line">  <span class="keyword">int</span> current_tick;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*alarmhandler)();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>We also need to modify <code>allocproc()</code> in <code>proc.c</code> to initialize the fields we added.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;current_tick = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarmticks = <span class="number">-1</span>;     <span class="comment">// initialize alarmticks to -1</span></span><br></pre></td></tr></table></figure><p>In <code>syscall.c</code>, add a function <code>sys_alarm</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_alarm</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ticks;</span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*handler)();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argptr</span>(<span class="number">1</span>, (<span class="keyword">char</span>**)&amp;handler, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">myproc</span>()-&gt;alarmticks = ticks;</span><br><span class="line">  <span class="built_in">myproc</span>()-&gt;alarmhandler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In <code>trap.c</code>, add code handle case <code>IRQ_TIMER</code>.<br>In kernel mode, we can’t directly call <code>alarmhandler</code>. However, we need to modify the trapframe.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">cpuid</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">    ticks++;</span><br><span class="line">    <span class="built_in">wakeup</span>(&amp;ticks);</span><br><span class="line">    <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">lapiceoi</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// alarm </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">if</span>(p != <span class="number">0</span> &amp;&amp; (tf-&gt;cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">    p-&gt;current_tick++;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;current_tick == p-&gt;alarmticks) &#123;</span><br><span class="line">      p-&gt;current_tick = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// push old eip</span></span><br><span class="line">      tf-&gt;esp -= <span class="number">4</span>;</span><br><span class="line">      *(uint *)(tf-&gt;esp) = tf-&gt;eip;</span><br><span class="line">      <span class="comment">// set eip to alarmhandler</span></span><br><span class="line">      tf-&gt;eip = (uint)p-&gt;alarmhandler;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 HW5</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 HW4 lazy page allocation</title>
    <link href="https://moe.lovmayoi.top/2022/03/30/mit-6-828-hw4/"/>
    <id>https://moe.lovmayoi.top/2022/03/30/mit-6-828-hw4/</id>
    <published>2022-03-30T03:04:36.000Z</published>
    <updated>2022-03-30T03:10:45.322Z</updated>
    
    <content type="html"><![CDATA[<p>Add lazy page allcation feature to delay allocation of each page of memory until the application tries to use that page.</p><h3 id="Part-One-Eliminate-allocation-from-sbrk"><a href="#Part-One-Eliminate-allocation-from-sbrk" class="headerlink" title="Part One: Eliminate allocation from sbrk()"></a>Part One: Eliminate allocation from sbrk()</h3><p>Just increment the process’s size (myproc()-&gt;sz) by n and return the old size, no allocation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">int</span> newsz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = <span class="built_in">myproc</span>()-&gt;sz;</span><br><span class="line">  <span class="comment">// if(growproc(n) &lt; 0)</span></span><br><span class="line">    <span class="comment">// return -1;</span></span><br><span class="line">  newsz = addr + n;</span><br><span class="line">  <span class="built_in">myproc</span>()-&gt;sz = newsz; </span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Part-Two-Lazy-allocation"><a href="#Part-Two-Lazy-allocation" class="headerlink" title="Part Two: Lazy allocation"></a>Part Two: Lazy allocation</h3><p>Modify <code>trap.c</code> to handle the page fault by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mappages</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, uint size, uint pa, <span class="keyword">int</span> perm)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap</span><span class="params">(struct trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span>(tf-&gt;trapno)&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="comment">//PAGEBREAK: 13</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span>(tf-&gt;trapno == T_PGFLT) &#123;</span><br><span class="line">      uint vaddr = <span class="built_in">PGROUNDDOWN</span>(<span class="built_in">rcr2</span>());</span><br><span class="line">      <span class="keyword">char</span> *mem = <span class="built_in">kalloc</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> lazy_alloc_fail;</span><br><span class="line">      <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">mappages</span>(<span class="built_in">myproc</span>()-&gt;pgdir, (<span class="keyword">char</span>*)vaddr, PGSIZE, <span class="built_in">V2P</span>(mem), PTE_W|PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">kfree</span>(mem);</span><br><span class="line">        <span class="keyword">goto</span> lazy_alloc_fail;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">lazy_alloc_fail:</span><br><span class="line">    <span class="comment">// In user space, assume process misbehaved.</span></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;pid %d %s: trap %d err %d on cpu %d &quot;</span></span><br><span class="line">            <span class="string">&quot;eip 0x%x addr 0x%x--kill proc\n&quot;</span>,</span><br><span class="line">            <span class="built_in">myproc</span>()-&gt;pid, <span class="built_in">myproc</span>()-&gt;name, tf-&gt;trapno,</span><br><span class="line">            tf-&gt;err, <span class="built_in">cpuid</span>(), tf-&gt;eip, <span class="built_in">rcr2</span>());</span><br><span class="line">    <span class="built_in">myproc</span>()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 HW4</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 HW3 system calls</title>
    <link href="https://moe.lovmayoi.top/2022/03/30/mit-6-828-hw3/"/>
    <id>https://moe.lovmayoi.top/2022/03/30/mit-6-828-hw3/</id>
    <published>2022-03-30T02:30:52.000Z</published>
    <updated>2022-03-30T03:02:25.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h3><p>Modify the syscall() function in syscall.c to print out a line for each system call invocation.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> table[<span class="number">22</span>][<span class="number">10</span>] = &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  num = curproc-&gt;tf-&gt;eax;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    curproc-&gt;tf-&gt;eax = syscalls[num]();</span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%s -&gt; %d\n&quot;</span>, table[num], curproc-&gt;tf-&gt;eax);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">    curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h3><p>Add a date system call to xv6.</p><p>In <code>user.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uptime</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">date</span><span class="params">(struct rtcdate*)</span></span>;  <span class="comment">// add this</span></span><br></pre></td></tr></table></figure><p>In <code>user.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL(fork)</span><br><span class="line">; ...</span><br><span class="line">SYSCALL(uptime)</span><br><span class="line">SYSCALL(date)       ; add this</span><br></pre></td></tr></table></figure><p>In <code>syscall.c</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_chdir</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_uptime</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_date</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// add this</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">[SYS_date]    sys_date,     <span class="comment">// add this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In <code>syscall.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_date   22       <span class="comment">// add this</span></span></span><br></pre></td></tr></table></figure><p>In <code>sysproc.c</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_date</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> *<span class="title">dt</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">argptr</span>(<span class="number">0</span>, (<span class="keyword">void</span> *)&amp;dt, <span class="built_in"><span class="keyword">sizeof</span></span>(*dt)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">cmostime</span>(dt);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, create a new file <code>date.c</code>, and add <code>_date</code> to the <code>UPROGS</code> definition in <code>Makefile</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;date.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span> <span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">date</span>(&amp;r)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">2</span>, <span class="string">&quot;date failed\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">0</span>, <span class="string">&quot;%d-%d-%d %d:%d:%d\n&quot;</span>, r.year, r.month, r.day, r.hour, r.minute, r.second);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And we can see the result in xv6 shell.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">❯ make qemu-nox</span><br><span class="line">qemu-system-i386 -nographic -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp 2 -m 512</span><br><span class="line">xv6...</span><br><span class="line">cpu1: starting 1</span><br><span class="line">cpu0: starting 0</span><br><span class="line">sb: size 1000 nblocks 941 ninodes 200 nlog 30 logstart 2 inodestart 32 bmap start 58</span><br><span class="line">init: starting sh</span><br><span class="line">$ date</span><br><span class="line">2022-3-30 3:2:12</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 HW3</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 HW2 shell</title>
    <link href="https://moe.lovmayoi.top/2022/03/30/mit-6-828-hw2/"/>
    <id>https://moe.lovmayoi.top/2022/03/30/mit-6-828-hw2/</id>
    <published>2022-03-30T02:30:45.000Z</published>
    <updated>2022-03-30T02:43:56.782Z</updated>
    
    <content type="html"><![CDATA[<p>In this HW, we implement several features in a small shell.</p><h3 id="Executing-simple-commands"><a href="#Executing-simple-commands" class="headerlink" title="Executing simple commands"></a>Executing simple commands</h3><p>Fill the ‘’ case in <code>runcmd</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">  ecmd = (struct execcmd*)cmd;</span><br><span class="line">  <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">execv</span>(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv) == <span class="number">-1</span>))</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;execv failed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="I-O-redirection"><a href="#I-O-redirection" class="headerlink" title="I/O redirection"></a>I/O redirection</h3><p>Use the trick that <code>open</code> will choose the smallest free file descriptor.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">  rcmd = (struct redircmd*)cmd;</span><br><span class="line">  <span class="built_in">close</span>(rcmd-&gt;fd);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">open</span>(rcmd-&gt;file, rcmd-&gt;flags, S_IRWXU) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;open failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">runcmd</span>(rcmd-&gt;cmd);</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="Implement-Pipes"><a href="#Implement-Pipes" class="headerlink" title="Implement Pipes"></a>Implement Pipes</h3><p>Use <code>pipe</code> and <code>dup</code>. Mind to close pipefds correctly and wait for child processes.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">  pcmd = (struct pipecmd*)cmd;</span><br><span class="line">  <span class="keyword">int</span> pipefds[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">pipe</span>(pipefds)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;create pipe failed\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pid1, pid2;</span><br><span class="line">  <span class="keyword">if</span> ((pid1 = fork1()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">dup</span>(pipefds[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipefds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipefds[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">runcmd</span>(pcmd-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pid2 = fork1()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">close</span>(STDIN_FILENO);</span><br><span class="line">      <span class="built_in">dup</span>(pipefds[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">close</span>(pipefds[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">close</span>(pipefds[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">runcmd</span>(pcmd-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">close</span>(pipefds[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">close</span>(pipefds[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">      <span class="built_in">wait</span>(&amp;r);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 HW2</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 Lab2</title>
    <link href="https://moe.lovmayoi.top/2022/03/14/mit-6-828-lab2/"/>
    <id>https://moe.lovmayoi.top/2022/03/14/mit-6-828-lab2/</id>
    <published>2022-03-14T13:01:52.000Z</published>
    <updated>2022-04-04T12:07:16.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><h3 id="physical-page-allocator"><a href="#physical-page-allocator" class="headerlink" title="physical page allocator"></a>physical page allocator</h3><p>Write the physical page allocator. It keeps track of which pages are free with a linked list of struct PageInfo objects (which, unlike xv6, are not embedded in the free pages themselves), each corresponding to a physical page.</p><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><p>Implement the following functions.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init() (only up to the call to check_page_free_list(1))</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure><p><code>boot_alloc()</code> is a simple physical allocator which is used only while kernel is setting up its virtual memory system.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">boot_alloc</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;    <span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">    <span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line">    <span class="comment">// which points to the end of the kernel&#x27;s bss segment:</span></span><br><span class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">    <span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">    <span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">        nextfree = <span class="built_in">ROUNDUP</span>((<span class="keyword">char</span> *) end, PGSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span></span><br><span class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">    <span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)nextfree - KERNBASE &gt; (npages * PGSIZE - n)) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = nextfree;</span><br><span class="line">    nextfree = <span class="built_in">ROUNDUP</span>(nextfree + n, PGSIZE);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In <code>mem_init()</code>, add code to allocate an array of npages <code>struct PageInfo</code>s and store it in <code>pages</code>. The kernel uses this array to keep track of physical pages.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) <span class="built_in">boot_alloc</span>(npages * <span class="built_in"><span class="keyword">sizeof</span></span>(struct PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="built_in"><span class="keyword">sizeof</span></span>(struct PageInfo));</span><br></pre></td></tr></table></figure><p><code>page_init()</code> is used to initialize the page structure and memory free list.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page 0</span></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">    pages[<span class="number">0</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the rest of base memory</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IO hole</span></span><br><span class="line">    <span class="keyword">for</span> (i = IOPHYSMEM &gt;&gt; <span class="number">12</span>; i &lt; EXTPHYSMEM &gt;&gt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">    <span class="keyword">physaddr_t</span> end_of_kern = <span class="built_in">PADDR</span>(<span class="built_in">ROUNDUP</span>((<span class="keyword">char</span> *) end, PGSIZE));</span><br><span class="line">    <span class="keyword">int</span> size_of_table = <span class="built_in">ROUNDUP</span>(npages * <span class="built_in"><span class="keyword">sizeof</span></span>(struct PageInfo), PGSIZE) &gt;&gt; <span class="number">12</span>; </span><br><span class="line">    <span class="keyword">int</span> end_of_inuse_page = (end_of_kern &gt;&gt; <span class="number">12</span>) + <span class="number">1</span> + size_of_table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// in use extended memory, including kernel, kernpgdir and pages array</span></span><br><span class="line">    <span class="keyword">for</span> (i = EXTPHYSMEM &gt;&gt; <span class="number">12</span>; i &lt; end_of_inuse_page; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">        pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free extended memory</span></span><br><span class="line">    <span class="keyword">for</span> (i = end_of_inuse_page; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_alloc()</code> is used to allocate a physical page from the free list.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">victim</span> =</span> page_free_list;</span><br><span class="line"></span><br><span class="line">    page_free_list = victim-&gt;pp_link;</span><br><span class="line">    victim-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO)</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">page2kva</span>(victim), <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_free()</code> is used to free a physical page and put it into the free list. We need to check whether the page is still in use (using <code>pp_ref</code>) or the page has already been freed.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">    <span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;pp_ref)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;reference count non zero&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp-&gt;pp_link)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;double free detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pp-&gt;pp_link = page_free_list;</span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>In x86 terminology, a virtual address consists of a segment selector and an offset within the segment. A linear address is what you get after segment translation but before page translation. A physical address is what you finally get after both segment and page translation and what ultimately goes out on the hardware bus to your RAM.</p><p>In out inplementation, the <code>GDT</code> installed in <code>boot/boot.s</code> actually disabled segment translation by setting all segment base addresses to 0 and limits to 0xffffffff. Hence the “selector” has no effect and the linear address always equals the offset of the virtual address.</p><p>In the previous lab, we installed a simple page table to map only 4MB of physical memory at <code>0x00100000</code> to the virtual space starting at <code>0xf0100000</code>. This is sufficient for the kernel to start up, but we will need to set up the complete kernel space in the following part.</p><h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h4><div class="table-container"><table><thead><tr><th>C type</th><th>Address type</th></tr></thead><tbody><tr><td><code>T*</code></td><td>Virtual</td></tr><tr><td><code>uintptr_t</code></td><td>Virtual</td></tr><tr><td><code>physaddr_t</code></td><td>Physical</td></tr></tbody></table></div><p>Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value = return_a_pointer();</span><br><span class="line">*value = 10;</span><br><span class="line">x = (mystery_t) value;</span><br></pre></td></tr></table></figure><p>The answer is <code>uintptr_t</code>.</p><h3 id="Reference-Counting"><a href="#Reference-Counting" class="headerlink" title="Reference Counting"></a>Reference Counting</h3><p>We keep a count of the number of references to each physical page in the <code>pp_ref</code> field of the <code>struct PageInfo</code> corresponding to the physical page.  </p><p>When this count goes to zero for a physical page, that page can be freed because it is no longer used. In general, this count should be equal to the number of times the physical page appears below <code>UTOP</code> in all page tables (the mappings above <code>UTOP</code> are mostly set up at boot time by the kernel and should never be freed, so there’s no need to reference count them).  </p><p>We’ll also use it to keep track of the number of pointers we keep to the page directory pages and, in turn, of the number of references the page directories have to page table pages.</p><h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>Implement the following functions</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pgdir_walk()</span><br><span class="line">boot_map_region()</span><br><span class="line">page_lookup()</span><br><span class="line">page_remove()</span><br><span class="line">page_insert()</span><br></pre></td></tr></table></figure><p><code>pgdir_walk()</code> tries to find the relevant page table entry in the page directory for a given virtual address. If <code>create</code> equals to 1, it will create the corresponding page table if it does not exist. The function returns a pointer to the found page table entry.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">pgdir_walk</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pde_t</span> pde = pgdir[<span class="built_in">PDX</span>(va)];</span><br><span class="line">    <span class="keyword">pte_t</span> *pgtbl_ptr;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pde == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (create == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">new_pgtbl_info</span> =</span> <span class="built_in">page_alloc</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (new_pgtbl_info == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        new_pgtbl_info-&gt;pp_ref++;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">page2kva</span>(new_pgtbl_info), <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">        pde = pgdir[<span class="built_in">PDX</span>(va)] = <span class="built_in">page2pa</span>(new_pgtbl_info) | PTE_W | PTE_P | PTE_U;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pgtbl_ptr = (<span class="keyword">pte_t</span> *) <span class="built_in">KADDR</span>(<span class="built_in">PTE_ADDR</span>(pde));</span><br><span class="line">    <span class="keyword">return</span> (pgtbl_ptr + <span class="built_in">PTX</span>(va));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>boot_map_region()</code> maps [va, va+size) of virtual address space to physical [pa, pa+size) in the page table rooted at pgdir. It’s intended to set up the static mappings above <code>UTOP</code>, so <code>pp_ref</code> field of the mapped pages isn’t changed.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mind the alignment</span></span><br><span class="line">    <span class="keyword">int</span> cnt = size / PGSIZE;</span><br><span class="line">    <span class="keyword">if</span> (size % PGSIZE) cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *pte_ptr = <span class="built_in">pgdir_walk</span>(pgdir, (<span class="keyword">const</span> <span class="keyword">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">        (*pte_ptr) = pa | perm | PTE_P;</span><br><span class="line">        va += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_lookup()</code> returns the page mapped at virtual address ‘va’. If <code>pte_store</code> is not zero, then we store in it the address of the pte for this page.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr = <span class="built_in">pgdir_walk</span>(pgdir, va, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_ptr != <span class="literal">NULL</span> &amp;&amp; (*pte_ptr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pte_store != <span class="literal">NULL</span>)</span><br><span class="line">            (*pte_store) = pte_ptr;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pa2page</span>(<span class="built_in">PTE_ADDR</span>(*pte_ptr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_remove()</code> unmaps the page at virtual address ‘va’. It needs to call <code>page_decref()</code> and <code>tlb_invalidate()</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> =</span> <span class="built_in">page_lookup</span>(pgdir, va, &amp;pte_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*pte_ptr) != <span class="number">0</span>) &#123;</span><br><span class="line">            (*pte_ptr) = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">tlb_invalidate</span>(pgdir, va);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">page_decref</span>(page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>page_insert()</code> maps the physical page <code>pp</code> at virtual address <code>va</code>. If there is already a page mapped at <code>va</code>, it will be removed using <code>page_remove()</code>. And <code>pp_ref</code> should be incremented it the insertion succeeds.<br>There is a corner case which requires attention. If the same <code>pp</code> is re-inserted at the same virtual address in the same pgdir, if we call <code>page_remove()</code> before incrementing the <code>pp_ref</code>, the page may be freed because of the call to <code>page_decref()</code> in <code>page_remove()</code>.<br>By incrementing <code>pp_ref</code> before calling <code>page_remove()</code>, we can elegantly handle the corner case.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte_ptr = <span class="built_in">pgdir_walk</span>(pgdir, va, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pte_ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment pp_ref before page_remove() to handle corner case</span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*pte_ptr) != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">page_remove</span>(pgdir, va);</span><br><span class="line"></span><br><span class="line">    (*pte_ptr) = <span class="built_in">page2pa</span>(pp) | perm | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>The virtual space layout is like this.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                Permissions</span></span><br><span class="line"><span class="comment"> *                                                    kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    4 Gig --------&gt;  +------------------------------+</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     :              .               :</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *                     |   Remapped Physical Memory   | RW/--</span></span><br><span class="line"><span class="comment"> *                     |                              | RW/--</span></span><br><span class="line"><span class="comment"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span></span><br><span class="line"><span class="comment"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *                     :              .               :                   |</span></span><br><span class="line"><span class="comment"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span></span><br><span class="line"><span class="comment"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span></span><br><span class="line"><span class="comment"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span></span><br><span class="line"><span class="comment"> *                     |          RO PAGES            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span></span><br><span class="line"><span class="comment"> *                     |           RO ENVS            | R-/R-  PTSIZE</span></span><br><span class="line"><span class="comment"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span></span><br><span class="line"><span class="comment"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebff000</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span></span><br><span class="line"><span class="comment"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span></span><br><span class="line"><span class="comment"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span></span><br><span class="line"><span class="comment"> *                     +------------------------------+ 0xeebfd000</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     .                              .</span></span><br><span class="line"><span class="comment"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span></span><br><span class="line"><span class="comment"> *                     |     Program Data &amp; Heap      |</span></span><br><span class="line"><span class="comment"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span></span><br><span class="line"><span class="comment"> *                     |                              |</span></span><br><span class="line"><span class="comment"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *                     | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="comment"> *                     |  User STAB Data (optional)   |                 PTSIZE</span></span><br><span class="line"><span class="comment"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span></span><br><span class="line"><span class="comment"> *                     |       Empty Memory (*)       |                   |</span></span><br><span class="line"><span class="comment"> *    0 ------------&gt;  +------------------------------+                 --+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>We use the permission bits in the page table to control access and implement page-level isolation.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Page Directory Entry     Page Table Entry      Combined Protection</span><br><span class="line">U/S          R/W         U/S      R/W          U/S         R/W</span><br><span class="line"></span><br><span class="line">S-0          R-0         S-0      R-0           S           x</span><br><span class="line">S-0          R-0         S-0      W-1           S           x</span><br><span class="line">S-0          R-0         U-1      R-0           S           x</span><br><span class="line">S-0          R-0         U-1      W-1           S           x</span><br><span class="line">S-0          W-1         S-0      R-0           S           x</span><br><span class="line">S-0          W-1         S-0      W-1           S           x</span><br><span class="line">S-0          W-1         U-1      R-0           S           x</span><br><span class="line">S-0          W-1         U-1      W-1           S           x</span><br><span class="line">U-1          R-0         S-0      R-0           S           x</span><br><span class="line">U-1          R-0         S-0      W-1           S           x</span><br><span class="line">U-1          R-0         U-1      R-0           U           R</span><br><span class="line">U-1          R-0         U-1      W-1           U           R</span><br><span class="line">U-1          W-1         S-0      R-0           S           x</span><br><span class="line">U-1          W-1         S-0      W-1           S           x</span><br><span class="line">U-1          W-1         U-1      R-0           U           R</span><br><span class="line">U-1          W-1         U-1      W-1           U           W</span><br></pre></td></tr></table></figure><h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>Now we use <code>boot_map_region</code> which we just implemented to initialize the kernel address space above <code>UTOP</code>.</p><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>Fill in the missing code in mem_init() after the call to check_page().</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="built_in">boot_map_region</span>(kern_pgdir, UPAGES, PTSIZE, <span class="built_in">PADDR</span>(pages), PTE_U);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="built_in">boot_map_region</span>(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, <span class="built_in">PADDR</span>(bootstack), PTE_W);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="built_in">boot_map_region</span>(kern_pgdir, KERNBASE, <span class="number">0x0fffffff</span>, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure><h4 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h4><ul><li>What entries (rows) in the page directory have been filled in at this point?</li></ul><div class="table-container"><table><thead><tr><th>Entry</th><th>Base Virtual Address</th><th>Points to (logically)</th></tr></thead><tbody><tr><td>1023</td><td>0xffc00000</td><td>Page table for top 4MB of phys memory</td></tr><tr><td>1022</td><td>0xff800000</td><td></td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>960</td><td>0xf0000000</td><td>Page table for bottom 4MB of phys memory</td></tr><tr><td>959</td><td>0xefff8000</td><td>Page table for kernel stack</td></tr><tr><td>957</td><td>0xef400000</td><td>PD itself as a page table</td></tr><tr><td>956</td><td>0xef000000</td><td>Page table of pages mapped at UPAGES</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>2</td><td>?</td><td>?</td></tr><tr><td>1</td><td>?</td><td>?</td></tr><tr><td>0</td><td>?</td><td>?</td></tr></tbody></table></div><ul><li><p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p><ul><li>Page level protection. The U/S bit in PTEs.</li></ul></li><li><p>What is the maximum amount of physical memory that this operating system can support? Why?</p><ul><li>2GB. npages = 524288, max amount of physical memory = npages * 4KB = 2GB.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));</span><br></pre></td></tr></table></figure></li><li><p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p><ul><li>Size of <code>pages</code> = npages * sizeof(struct PageInfo);</li><li>Size of <code>kern_pgdir</code> = PGSIZE</li><li>Total size of all page tables = PGSIZE * 1K</li></ul></li><li><p>Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p><ul><li><code>jmp *%eax</code> does the trasition. Because we set up a <code>entry_pgdir</code> to map virtual addresses [KERNBASE, KERNBASE+4MB) to physical addresses [0, 4MB). Because we need kernel to run at the virtual space above <code>KERNBASE</code>, leaving the virtual space below for user process.</li></ul></li></ul><h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><p>Extend the JOS kernel monitor with commands <code>showmappings</code>, <code>setpermbits</code> and <code>dumpmem</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span>*</span></span><br><span class="line"><span class="function"><span class="title">pageperm2str</span><span class="params">(<span class="keyword">pte_t</span> pte, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *str[] = &#123; <span class="string">&quot;_________SR_&quot;</span>, <span class="string">&quot;AVLGPDACTUWP&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">        buf[i] = str[pte &gt;&gt; (<span class="number">11</span> - i) &amp; <span class="number">0x1</span>][i];</span><br><span class="line">    buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">str2pageperm</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pri = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*buf != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (*buf++) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">                pri |= PTE_P;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                pri |= PTE_W;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">                pri |= PTE_U;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                pri |= PTE_PWT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                pri |= PTE_PCD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                pri |= PTE_A;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                pri |= PTE_D;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">                pri |= PTE_G;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_showmappings</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> &amp;&amp; argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Wrong number of arguments.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Usage: showmappings begin_vaddr [end_vaddr]\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin, end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pptr;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">ROUNDDOWN</span>((<span class="keyword">uint32_t</span>)<span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>), PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>)</span><br><span class="line">        end = begin;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        end = <span class="built_in">ROUNDDOWN</span>((<span class="keyword">uint32_t</span>)<span class="built_in">strtol</span>(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>), PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (begin &gt; <span class="number">0xf7ffffff</span> || end &gt; <span class="number">0xf7ffffff</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual Address out of range.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%8s\t%8s\t%12s\n&quot;</span>, <span class="string">&quot;VA&quot;</span>, <span class="string">&quot;PA&quot;</span>, <span class="string">&quot;PERMBITS&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (; begin &lt;= end; begin += PGSIZE) &#123;</span><br><span class="line">        pp = <span class="built_in">page_lookup</span>(kern_pgdir, (<span class="keyword">void</span> *)begin, &amp;pptr);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">pageperm2str</span>(*pptr, buf);</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t%08x\t%12s\n&quot;</span>, begin, <span class="built_in">page2pa</span>(pp), buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t%8s\t%12s\n&quot;</span>, begin, <span class="string">&quot;none&quot;</span>, <span class="string">&quot;none&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_setpermbits</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Wrong number of arguments.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Usage: setpermbits +/-permbits vaddr\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="keyword">pte_t</span> *pptr, pte;</span><br><span class="line">    <span class="keyword">char</span> buf_old[<span class="number">15</span>], buf_new[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">       begin = <span class="built_in">ROUNDDOWN</span>((<span class="keyword">uint32_t</span>) <span class="built_in">strtol</span>(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>), PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (begin &gt; <span class="number">0xf7ffffff</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual Address out of range.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pp = <span class="built_in">page_lookup</span>(kern_pgdir, (<span class="keyword">void</span> *)begin, &amp;pptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;No mpping exists.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pte = *pptr;</span><br><span class="line">    <span class="keyword">if</span> (*argv[<span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span>) </span><br><span class="line">        *pptr |= <span class="built_in">str2pageperm</span>(argv[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*argv[<span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        *pptr &amp;= ~<span class="built_in">str2pageperm</span>(argv[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual\t\tPhysical\tOld Priority\tNew Priority\t\n&quot;</span>);</span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t%08x\t%12s\t%12s\n&quot;</span>, begin, <span class="built_in">page2pa</span>(pp), <span class="built_in">pageperm2str</span>(pte, buf_old), <span class="built_in">pageperm2str</span>(*pptr, buf_new));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mon_dumpmem</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Wrong number of arguments.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Usage: dumpmem -p/v begin_addr end_addr\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin, end;</span><br><span class="line"></span><br><span class="line">       begin = (<span class="keyword">uint32_t</span>) <span class="built_in">strtol</span>(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">       end = (<span class="keyword">uint32_t</span>) <span class="built_in">strtol</span>(argv[<span class="number">3</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">PGNUM</span>(begin) &gt;= npages) || (<span class="built_in">PGNUM</span>(end) &gt;= npages)) &#123;</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;Physical address out of range.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin = (<span class="keyword">uint32_t</span>) <span class="built_in">KADDR</span>(begin);</span><br><span class="line">        end = (<span class="keyword">uint32_t</span>) <span class="built_in">KADDR</span>(end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= <span class="number">0xf7ffffff</span> || end &gt;= <span class="number">0xf7ffffff</span>) &#123;</span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual address out of range.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;Virtual\t\tPhysical\tMemory Contents\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">pte_t</span> *pptr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t&quot;</span>, begin);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">page_lookup</span>(kern_pgdir, (<span class="keyword">void</span> *) begin, &amp;pptr) == <span class="literal">NULL</span> || *pptr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;No Mapping\n&quot;</span>);</span><br><span class="line">            begin += PGSIZE - begin % PGSIZE;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;%08x\t&quot;</span>, <span class="built_in">PTE_ADDR</span>(*pptr) | <span class="built_in">PGOFF</span>(begin));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++, begin++)</span><br><span class="line">            <span class="built_in">cprintf</span>(<span class="string">&quot;%02x &quot;</span>, *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) begin);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cprintf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 Lab2</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 HW1 Boot xv6</title>
    <link href="https://moe.lovmayoi.top/2022/02/28/mit-6-828-hw1/"/>
    <id>https://moe.lovmayoi.top/2022/02/28/mit-6-828-hw1/</id>
    <published>2022-02-28T06:11:21.000Z</published>
    <updated>2022-03-30T02:32:59.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h3><p>Clone the repository and build xv6.</p><h3 id="Finding-and-breaking-at-an-address"><a href="#Finding-and-breaking-at-an-address" class="headerlink" title="Finding and breaking at an address"></a>Finding and breaking at an address</h3><p>We can find the address of <code>_start</code> at <code>0x0010000c</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">❯ nm kernel | grep _start</span><br><span class="line">8010a48c D _binary_entryother_start</span><br><span class="line">8010a460 D _binary_initcode_start</span><br><span class="line">0010000c T _start</span><br></pre></td></tr></table></figure><p>Set a break point there and run into it in gdb.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; target remote localhost:26000</span><br><span class="line">Remote debugging using localhost:26000</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line"></span><br><span class="line">pwndbg&gt; b * 0x0010000c</span><br><span class="line">Breakpoint 1 at 0x10000c</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, 0x0010000c in ?? ()</span><br><span class="line">► 0x10000c    mov    eax, cr4</span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h3 id="Exercise-What-is-on-the-stack"><a href="#Exercise-What-is-on-the-stack" class="headerlink" title="Exercise: What is on the stack?"></a>Exercise: What is on the stack?</h3><p>At the above breakpoint, inspect the register valuea and the stack contents.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; info reg</span><br><span class="line">eax            0x0                 0</span><br><span class="line">ecx            0x0                 0</span><br><span class="line">edx            0x1f0               496</span><br><span class="line">ebx            0x10094             65684</span><br><span class="line">esp            0x7bdc              0x7bdc</span><br><span class="line">ebp            0x7bf8              0x7bf8</span><br><span class="line">esi            0x10094             65684</span><br><span class="line">edi            0x0                 0</span><br><span class="line">eip            0x10000c            0x10000c</span><br><span class="line">eflags         0x46                [ PF ZF ]</span><br><span class="line">cs             0x8                 8</span><br><span class="line">ss             0x10                16</span><br><span class="line">ds             0x10                16</span><br><span class="line">es             0x10                16</span><br><span class="line">fs             0x0                 0</span><br><span class="line">gs             0x0                 0</span><br><span class="line">pwndbg&gt; x/24x $esp</span><br><span class="line">0x7bdc: 0x00007d97      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7bec: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7bfc: 0x00007c4d      0x8ec031fa      0x8ec08ed8      0xa864e4d0</span><br><span class="line">0x7c0c: 0xb0fa7502      0xe464e6d1      0x7502a864      0xe6dfb0fa</span><br><span class="line">0x7c1c: 0x16010f60      0x200f7c78      0xc88366c0      0xc0220f01</span><br><span class="line">0x7c2c: 0x087c31ea      0x10b86600      0x8ed88e00      0x66d08ec0</span><br></pre></td></tr></table></figure><ul><li>Where in bootasm.S is the stack pointer initialized?<ul><li>At line 65, <code>movl    $start, %esp</code>, <code>esp</code> was set to <code>0x7c00</code>.</li></ul></li><li>Single step through the call to bootmain; what is on the stack now?<ul><li>The saved <code>eip</code> which points to <code>0x7c4d</code>, otherwise, the return address of <code>bootmain()</code>.</li></ul></li><li>What do the first assembly instructions of bootmain do to the stack?<ul><li>They save the old <code>ebp</code> and make a stack frame by set <code>ebp</code> to the value of <code>esp</code>, then save the old <code>edi</code>, <code>esi</code>, <code>ebx</code>, and subtract <code>esp</code> by 0x10.</li></ul></li><li>Look for the call that changes eip to 0x10000c. What does that call do to the stack?<ul><li>The call is at <code>0x7d91</code>, <code>call   *0x10018</code>. This call pushes current <code>eip</code> on the stack.</li></ul></li></ul><p>So now we can figure out the non-zero value on the stack at the above breakpoint. The <code>0x7c4d</code> at <code>0x7bfc</code> and <code>0x7d97</code> at <code>0x7bdc</code> are both old <code>eip</code> saved by call.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x7c00: 0x8ec031fa not the stack</span><br><span class="line">0x7bfc: 0x00007c4d bootmain() return address</span><br><span class="line">0x7bf8: 0x00000000 old ebp</span><br><span class="line">0x7bf4: 0x00000000 old edi</span><br><span class="line">0x7bf0: 0x00000000 old esi</span><br><span class="line">0x7bec: 0x00000000 old ebx</span><br><span class="line">0x7be8: 0x00000000</span><br><span class="line">0x7be4: 0x00000000</span><br><span class="line">0x7be0: 0x00000000 local vars</span><br><span class="line">0x7bdc: 0x00007d97 entry() return addres</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 HW1.</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>MIT 6.828 Lab1</title>
    <link href="https://moe.lovmayoi.top/2022/02/04/mit-6-828-lab1/"/>
    <id>https://moe.lovmayoi.top/2022/02/04/mit-6-828-lab1/</id>
    <published>2022-02-04T11:47:36.000Z</published>
    <updated>2022-02-25T13:21:29.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>A PC’s physical address space is hard-wired to have the following general layout.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>The IBM PC starts with <code>CS = 0xf000</code> and <code>IP = 0xfff0</code>, executing at physical address <code>0x000ffff0</code>, which is at the very top of the 64KB area reserved for the ROM BIOS.  </p><blockquote><p>In real mode (the mode that PC starts off in), address translation works according to the formula: physical address = 16 * segment + offset.</p></blockquote><p>The BIOS in a PC is “hard-wired” to the physical address range <code>0x000f0000-0x000fffff</code>, this design ensures that the BIOS always gets control of the machine first after power-up or any system restart.</p><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p>Generally, the BIOS performs the following tasks</p><ul><li>Sets up an IDT (Interrupt Descriptor Table，中断向量表)</li><li>Initializes various devices such as the VGA display</li><li>After initializing the PCI bus and all the important devices the BIOS knows about, it searches for a bootable device such as a floppy, hard drive, or CD-ROM. When it finds a bootable disk, the BIOS reads the <strong>boot loader</strong> from the disk and transfers control to it.</li></ul><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><h3 id="The-Boot-loader"><a href="#The-Boot-loader" class="headerlink" title="The Boot loader"></a>The Boot loader</h3><p>Floppy and hard disks for PCs are divided into 512 byte regions called sectors. The first sector of a bootable disk is called the <em>boot sector</em>.  </p><p>When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses <code>0x7c00</code> through <code>0x7dff</code>, and then uses a <code>jmp</code> instruction to set the <code>CS:IP</code> to <code>0000:7c00</code>, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs.  </p><p>The boot loader performs the following functions:</p><ul><li><p>First, switch the processor from real mode to <strong>32-bit protected mode</strong>, because it is only in this mode that software can access all the memory above 1MB in the processor’s physical address space. The boot loader sets the <code>$CR0_PE_ON</code> bit in register <code>cr0</code> and loads the GDT.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # and segment translation that makes virtual addresses </span><br><span class="line">  # identical to their physical addresses, so that the </span><br><span class="line">  # effective memory map does not change during the switch.</span><br><span class="line">  lgdt    gdtdesc</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  </span><br><span class="line">  # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">  # Switches processor into 32-bit mode.</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL                                # null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)       # code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)             # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>GDT (Global Descriptor Table)</strong> is a significant structure in protected mode.<br>Typically, we access memory address by <code>selector:offset</code>. In real mode,   a selector is an paragraph number of physical memory. In protected mode, a selector value is an intex into a descriptor table, and each segment is assigned an entry in a descriptor table.<br>The whole system has one Global Descriptor Table. Its entry address and limit of length are hold in register <code>GDTR</code>. During protected mode initialization, we have to use the instruction <code>lgdt</code> to assign <code>GDTR</code> with a new value.<br>The structure of GDT entry is as the following. It specifies the base and limit address of the segment and access properties (that’s why it’s called <strong>protected</strong> mode).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struc gdt_entry_struct</span><br><span class="line">  limit_low:    resb 2</span><br><span class="line">  base_low:     resb 2</span><br><span class="line">  base_middle:  resb 1</span><br><span class="line">  access:       resb 1</span><br><span class="line">  granularity:  resb 1</span><br><span class="line">  base_high:    resb 1</span><br><span class="line">end struc </span><br></pre></td></tr></table></figure></blockquote><ul><li><p>Second, the boot loader reads the <strong>kernel</strong> from the hard disk by directly accessing the IDE disk device registers via the x86’s special I/O instructions.</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">  ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">  eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">  <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">  <span class="comment">// note: does not return!</span></span><br><span class="line">  ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure></li></ul><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><ul><li>After this instruction <code>ljmp    $PROT_MODE_CSEG, $protcseg</code>, the processor starts to work in 32-bit mode. The cause is that <code>ljmp</code> loads the value of <code>$PROT_MODE_CSEG</code> into <code>CS</code>, and the value of <code>$protcseg</code> into <code>EIP</code>. After that, the processor will use the value of <code>CS</code> as an index of GDT to find the corresponding segment descriptor.</li><li>The last instruction of the boot loader is <code>call   *0x10018</code>, the first instruction of the kernel is <code>movw   $0x1234,0x472</code>.</li><li>The first instruction of the kernel is in file <code>kern/entry.s</code>, at address <code>0x10000c</code>.</li><li>The boot loader reads the <code>ELFHDR-&gt;e_phnum</code> from kernel’s elf header, and uses the <code>ph-&gt;p_memsz</code> to decide how many sectors to read per segment.</li></ul><h3 id="Loading-the-kernel"><a href="#Loading-the-kernel" class="headerlink" title="Loading the kernel"></a>Loading the kernel</h3><p>We can examine the ELF section headers like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ objdump -h obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001acd  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br></pre></td></tr></table></figure><ul><li>LMA(load address): The load address of a section is the memory address at which that section should be loaded into memory.</li><li>VMA(link address): The link address of a section is the memory address from which the section expects to execute.<br>Typically, the link and load addresses are the same.</li></ul><p>The boot loader users the ELF program headers to decide how to load the sections. The program headers specify which parts of the ELF object to load into memory and the destination address each should occupy.<br>We can inspect the program header like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ objdump -x obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line">obj/kern/kernel</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br><span class="line"></span><br><span class="line">Program Header:</span><br><span class="line">    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 2**12</span><br><span class="line">         filesz 0x00007e20 memsz 0x00007e20 flags r-x</span><br><span class="line">    LOAD off    0x00009000 vaddr 0xf0108000 paddr 0x00108000 align 2**12</span><br><span class="line">         filesz 0x0000b6a8 memsz 0x0000b6a8 flags rw-</span><br><span class="line">   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4</span><br><span class="line">         filesz 0x00000000 memsz 0x00000000 flags rwx</span><br></pre></td></tr></table></figure><p><code>vaddr</code> means virtual addresss and <code>paddr</code> means physical address.</p><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>We can change the link address of boot loader by modifying option <code>-Ttext</code> boot/Makefrag. For example, <code>0x7d00</code>.  </p><p>After changing this, boot loader will break at <code>ljmp    $PROT_MODE_CSEG, $protcseg</code> because the boot loader is executing from an address (<code>0x7c00</code>) that is different from the address from which it expects to execute (<code>0x7d00</code>).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">[   0:7c2d] =&gt; 0x7c2d:  ljmp   $0x8,$0x7d32</span><br></pre></td></tr></table></figure><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel.  </p><p>The two results are different because the boot loader loads the kernel into that address.</p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>As we inspected above, there was a (rather large) disparity between the kernel’s link address (as printed by objdump) and its load address.  </p><p>Operating system kernels often like to be linked and run at very high virtual address, such as 0xf0100000, in order to leave the lower part of the processor’s virtual address space for user programs to use.  </p><p>We use the processor’s memory management hardware to map virtual address 0xf0100000 (the link address at which the kernel code expects to run) to physical address 0x00100000 (where the boot loader loaded the kernel into physical memory).</p><p>For now, we’ll just map the first 4MB of physical memory, using the hand-written, statically-initialized page directory and page table in <code>kern/entrypgdir.c</code>.  </p><p>After <code>kern/entry.S</code> sets the <code>CR0_PG</code> flag, paging is enabled, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses. <code>entry_pgdir</code> translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000.</p><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>We can examine memory at <code>0x00100000</code> and at <code>0xf0100000</code> before and after the <code>movl %eax, %cr0</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) x/10gx 0x00100000</span><br><span class="line">0x100000:       0x000000001badb002      0x7205c766e4524ffe</span><br><span class="line">0x100010:       0x2000b81234000004      0xc0200fd8220f0011</span><br><span class="line">0x100020:       0xc0220f800100010d      0xbde0fff010002fb8</span><br><span class="line">0x100030:       0x110000bc00000000      0xfeeb0000006ce8f0</span><br><span class="line">0x100040:       0x56e58955fb1e0ff3      0xc3810000017ee853</span><br><span class="line">(gdb) x/10gx 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:  0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100020 &lt;entry+20&gt;:  0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100030 &lt;relocated+1&gt;:       0x0000000000000000      0x0000000000000000</span><br><span class="line">0xf0100040 &lt;test_backtrace&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">(gdb) ni</span><br><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/10gx 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start-268435468&gt;:  0x000000001badb002      0x7205c766e4524ffe</span><br><span class="line">0xf0100010 &lt;entry+4&gt;:   0x2000b81234000004      0xc0200fd8220f0011</span><br><span class="line">0xf0100020 &lt;entry+20&gt;:  0xc0220f800100010d      0xbde0fff010002fb8</span><br><span class="line">0xf0100030 &lt;relocated+1&gt;:       0x110000bc00000000      0xfeeb0000006ce8f0</span><br><span class="line">0xf0100040 &lt;test_backtrace&gt;:    0x56e58955fb1e0ff3      0xc3810000017ee853</span><br></pre></td></tr></table></figure><p>The first instruction that would fail if the mapping weren’t in place is <code>mov $relocated, %eax</code>.</p><h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>The formatted print function <code>int cprintf(const char *fmt, ...)</code> is implemented in <code>kern/printf.c</code>, which relys on <code>lib/printfmt.c</code> and <code>kern/console.c</code>.</p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>Complete the code of <code>vprintfmt</code> in <code>lib/printfmt.c</code> to print octal numbers using patterns of the form “%o”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (unsigned) octal</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">  <span class="comment">// Replace this with your code.</span></span><br><span class="line">  num = getuint(&amp;ap, lflag);</span><br><span class="line">  base = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><ol><li><p>The interface between <code>printf.c</code> and <code>console.c</code> is function <code>void cputchar(int c)</code> that <code>console.c</code> exports.  </p><p> <code>printf.c</code> calls it in <code>static void putch(int ch, int *cnt)</code>, and passes the pointer to <code>putch</code> as an argument to <code>vprintfmt((void*)putch, &amp;cnt, fmt, ap)</code> that is called in function <code>vcprintf</code>. And <code>vcprintf</code> is called by function <code>cprintf</code>.</p></li><li><p>The following code is in function <code>static void cga_putc(int c)</code>, which is used to output characters to CGA/VGA display.  </p><p> The purpose of this piece of code is to deal with the situation where the position of the cursor exceeds the screen.  </p><p> <code>crt_pos</code> is the position of next character to be output, on the other hand, the position of the cursor. And <code>CRT_SIZE</code> = <code>CRT_ROWS</code> * <code>CRT_COLS</code>, so it means the maximum number of characters that can be displayed on the screen.  </p><p> It moves all the characters on the screen upward by one row (using <code>memmove</code>) , and fills the last row with <code>0x0x00 | &#39; &#39;</code>, and ends by recalculating <code>crt_pos</code>.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What is the purpose of this?</span></span><br><span class="line"><span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">  <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">    crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  crt_pos -= CRT_COLS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>fmt</code> points to the address of format string <code>&quot;x %d, y %x, z %d\n&quot;</code>.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vcprintf(fmt, ap); <span class="comment">// called by cprintf</span></span><br><span class="line">cons_putc(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">va_arg(*ap, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// now ap points to &amp;y</span></span><br><span class="line">cons_putc(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">va_arg(*ap, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// now ap points to &amp;z</span></span><br><span class="line">cons_putc(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">va_arg(*ap, <span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// now ap points to (char *)&amp;z + 4</span></span><br><span class="line">cons_putc(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">cons_putc(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>The output is <code>He110 World</code>. In big-endian, <code>i</code> should be set to <code>0x726c6400</code>. We don’t need to <code>57616</code>.</p></li><li><p>The 4 bytes of data on the stack below <code>3</code> will be treated as an integer and output.</p></li><li><p>We can change its interface so that when the function is called, arguments are passsed in reverse order.  </p></li></ol><blockquote><p><em>Challenge</em>: Enhance the console to allow text to be printed in different colors. Left to be done.</p></blockquote><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><p>The kernel initializes its stack in <code>entry.s</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl  $0x0,%ebp      # nuke frame pointer</span><br><span class="line"></span><br><span class="line"># Set the stack pointer</span><br><span class="line">movl  $(bootstacktop),%esp</span><br></pre></td></tr></table></figure><p>We can see the definition of <code>bootstacktop</code> in the data section of <code>entry.s</code>, the kernel reserves the space for the stack using <code>.space KSTAKSIZE</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">###################################################################</span><br><span class="line"># boot stack</span><br><span class="line">###################################################################</span><br><span class="line">  .p2align  PGSHIFT    # force page alignment</span><br><span class="line">  .globl    bootstack</span><br><span class="line">bootstack:</span><br><span class="line">  .space    KSTKSIZE</span><br><span class="line">  .globl    bootstacktop   </span><br><span class="line">bootstacktop:</span><br></pre></td></tr></table></figure><p>According to the result of debug, we know that the stack is located just above <code>entry_pgtable</code>, at <code>0x0xf0110000</code> where <code>esp</code> points to. And this is the lowest end of the stack.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf0100034 &lt;relocated+5&gt;:    mov    $0xf0110000,%esp</span><br><span class="line">relocated () at kern/entry.S:77</span><br><span class="line">77              movl    $(bootstacktop),%esp</span><br><span class="line">(gdb) p $esp</span><br><span class="line">$1 = (void *) 0xf0110000 &lt;entry_pgtable&gt;</span><br></pre></td></tr></table></figure><p>Various x86 instructions, such as call, are “hard-wired” to use the <code>esp</code>.  </p><p>The <code>ebp</code> (base pointer) register, in contrast, is associated with the stack primarily by software convention. On entry to a C function, the function’s prologue code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current esp value into <code>ebp</code> for the duration of the function.  </p><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><p>The address of the <code>test_backtrace</code> function is <code>0xf0100040</code>.  </p><p>First, it is called by function <code>void i386_init(void)</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test the stack backtrace function (lab 1 only)</span></span><br><span class="line">test_backtrace(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>It also recursively calls itself.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;entering test_backtrace %d\n&quot;</span>, x);</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">  test_backtrace(x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  mon_backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">cprintf(<span class="string">&quot;leaving test_backtrace %d\n&quot;</span>, x);</span><br></pre></td></tr></table></figure><p>Five 32-bit words are pushed on the stack by each recursive nesting call.  </p><p>They are saved <code>ebx</code>, saved <code>esi</code>, saved <code>ebp</code>, saved <code>eip</code>, and an argument x.  </p><h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><p>Implement the <code>mon_backtrace()</code> function to print the stack backtrace, and hook this function into the kernel monitor’s commmand list.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] =</span> &#123;</span><br><span class="line">  &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;kerninfo&quot;</span>, <span class="string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;backtrace&quot;</span>, <span class="string">&quot;Display stack backtrace&quot;</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> cur_ebp;</span><br><span class="line">  cur_ebp = read_ebp();</span><br><span class="line">  <span class="keyword">while</span> (cur_ebp) &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,</span><br><span class="line">      cur_ebp, ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">1</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">2</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">3</span>],</span><br><span class="line">      ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">4</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">5</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">6</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    cur_ebp = ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0110f58  eip f0100a99  args 00000001 f0110f80 00000000 f0100b01 f0100aa8</span><br><span class="line">  ebp f0110fd8  eip f0100109  args 00000000 00001aac 00000640 00000000 00000000</span><br><span class="line">  ebp f0110ff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br></pre></td></tr></table></figure><h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><p>Modify the stack backtrace function to display, for each eip, the function name, source file name, and line number corresponding to that eip.  </p><p>In <code>kern/kernel.ld</code>, we can find the code that include debugging information in kernel memory.  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Include debugging information in kernel memory */</span><br><span class="line">.stab : &#123;</span><br><span class="line">  PROVIDE(__STAB_BEGIN__ = .);</span><br><span class="line">  *(.stab);</span><br><span class="line">  PROVIDE(__STAB_END__ = .);</span><br><span class="line">  BYTE(0) /* Force the linker to allocate space</span><br><span class="line">         for this section */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stabstr : &#123;</span><br><span class="line">  PROVIDE(__STABSTR_BEGIN__ = .);</span><br><span class="line">  *(.stabstr);</span><br><span class="line">  PROVIDE(__STABSTR_END__ = .);</span><br><span class="line">  BYTE(0) /* Force the linker to allocate space</span><br><span class="line">         for this section */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the result of <code>objdump -h obj/kern/kernel</code>, we can find information of <code>.stab</code> and <code>.stabstr</code> in the sections of the kernel.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 .stab         00004375  f010229c  0010229c  0000329c  2**2</span><br><span class="line">                CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">3 .stabstr      00001999  f0106611  00106611  00007611  2**0</span><br><span class="line">                CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br></pre></td></tr></table></figure><p>In the result of <code>objdump -G obj/kern/kernel</code>, we can examine the contents of the .stab section, that are all the symbols.  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">❯  objdump -G obj/kern/kernel</span><br><span class="line"></span><br><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of .stab section:</span><br><span class="line"></span><br><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line"></span><br><span class="line">-1     HdrSym 0      1438   00001998 1</span><br><span class="line">0      SO     0      0      f0100000 1      &#123;standard input&#125;</span><br><span class="line">1      SOL    0      0      f010000c 18     kern/entry.S</span><br><span class="line">2      SLINE  0      44     f010000c 0</span><br></pre></td></tr></table></figure><p>Then we run <code>gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c</code>, and look at the <code>init.s</code>.  </p><p>We can see the contents of the <code>.stabs</code>.  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.Ltext0:</span><br><span class="line">  .stabs  &quot;gcc2_compiled.&quot;,60,0,0,0</span><br><span class="line">  .stabs  &quot;int:t(0,1)=r(0,1);-2147483648;2147483647;&quot;,128,0,0,0</span><br><span class="line">  .stabs  &quot;char:t(0,2)=r(0,2);0;127;&quot;,128,0,0,0</span><br></pre></td></tr></table></figure><p>So the bootloader loads the symbol table in memory as part of loading the kernel binary, and <code>debuginfo_eip</code> reads it.</p><p>We add this piece of code in <code>debuginfo_eip</code> to find the line number.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search within [lline, rline] for the line number stab.</span></span><br><span class="line"><span class="comment">// If found, set info-&gt;eip_line to the right line number.</span></span><br><span class="line"><span class="comment">// If not found, return -1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  There&#x27;s a particular stabs type used for line numbers.</span></span><br><span class="line"><span class="comment">//  Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span></span><br><span class="line"><span class="comment">//  which one.</span></span><br><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) &#123;</span><br><span class="line">  info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  info-&gt;eip_line = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And we modify the function <code>mon_backtrace</code> like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_backtrace</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> cur_ebp, cur_eip;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">  cur_ebp = read_ebp();</span><br><span class="line">  <span class="keyword">while</span> (cur_ebp) &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,</span><br><span class="line">      cur_ebp, ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">1</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">2</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">3</span>],</span><br><span class="line">      ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">4</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">5</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">6</span>], ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    cur_eip = ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">1</span>];</span><br><span class="line">    debuginfo_eip(cur_eip, &amp;info);</span><br><span class="line">    cprintf(<span class="string">&quot;         %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, cur_eip - info.eip_fn_addr);</span><br><span class="line"></span><br><span class="line">    cur_ebp = ((<span class="keyword">uint32_t</span> *)cur_ebp)[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0110f58  eip f0100abe  args 00000001 f0110f80 00000000 f0100b26 f0100acd</span><br><span class="line">         kern/monitor.c:138: monitor+343</span><br><span class="line">  ebp f0110fd8  eip f0100109  args 00000000 00001aac 00000640 00000000 00000000</span><br><span class="line">         kern/init.c:43: i386_init+95</span><br><span class="line">  ebp f0110ff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br><span class="line">         kern/entry.S:83: &lt;unknown&gt;+0</span><br></pre></td></tr></table></figure><p>Now, finally, lab1 is finished. Run <code>make grade</code> to see the grades.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">❯ make grade</span><br><span class="line">make clean</span><br><span class="line">make[1]: Entering directory &#x27;/home/shrimp/myfiles/6.828/lab&#x27;</span><br><span class="line">rm -rf obj .gdbinit jos.in qemu.log</span><br><span class="line">make[1]: Leaving directory &#x27;/home/shrimp/myfiles/6.828/lab&#x27;</span><br><span class="line">./grade-lab1</span><br><span class="line">make[1]: Entering directory &#x27;/home/shrimp/myfiles/6.828/lab&#x27;</span><br><span class="line">+ as kern/entry.S</span><br><span class="line">+ cc kern/entrypgdir.c</span><br><span class="line">+ cc kern/init.c</span><br><span class="line">+ cc kern/console.c</span><br><span class="line">+ cc kern/monitor.c</span><br><span class="line">+ cc kern/printf.c</span><br><span class="line">+ cc kern/kdebug.c</span><br><span class="line">+ cc lib/printfmt.c</span><br><span class="line">+ cc lib/readline.c</span><br><span class="line">+ cc lib/string.c</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">ld: warning: section `.bss&#x27; type changed to PROGBITS</span><br><span class="line">+ as boot/boot.S</span><br><span class="line">+ cc -Os boot/main.c</span><br><span class="line">+ ld boot/boot</span><br><span class="line">boot block is 412 bytes (max 510)</span><br><span class="line">+ mk obj/kern/kernel.img</span><br><span class="line">make[1]: Leaving directory &#x27;/home/shrimp/myfiles/6.828/lab&#x27;</span><br><span class="line">running JOS: (1.4s)</span><br><span class="line">  printf: OK</span><br><span class="line">  backtrace count: OK</span><br><span class="line">  backtrace arguments: OK</span><br><span class="line">  backtrace symbols: OK</span><br><span class="line">  backtrace lines: OK</span><br><span class="line">Score: 50/50</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Notes of MIT 6.828 Lab1.</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="OS" scheme="https://moe.lovmayoi.top/tags/OS/"/>
    
    <category term="kernel" scheme="https://moe.lovmayoi.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>让Hexo Blog支持Mathjax</title>
    <link href="https://moe.lovmayoi.top/2022/02/04/blog-add-mathjax/"/>
    <id>https://moe.lovmayoi.top/2022/02/04/blog-add-mathjax/</id>
    <published>2022-02-04T09:53:21.000Z</published>
    <updated>2022-02-04T14:59:13.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Add-themes-my-theme-layout-mathjax-ejs"><a href="#Add-themes-my-theme-layout-mathjax-ejs" class="headerlink" title="Add themes/*my_theme*/layout/mathjax.ejs"></a>Add <code>themes/*my_theme*/layout/mathjax.ejs</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.mathjax.enable)&#123; %&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      MathJax.Hub.Config(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="attr">tex2jax</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">inlineMath</span>: [ [<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>], [<span class="string">&quot;\\(&quot;</span>,<span class="string">&quot;\\)&quot;</span>] ],</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">processEscapes</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      MathJax.Hub.Config(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">tex2jax</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="attr">skipTags</span>: [<span class="string">&#x27;script&#x27;</span>, <span class="string">&#x27;noscript&#x27;</span>, <span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;textarea&#x27;</span>, <span class="string">&#x27;pre&#x27;</span>, <span class="string">&#x27;code&#x27;</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      MathJax.Hub.Queue(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="keyword">var</span> all = MathJax.Hub.getAllJax(), i;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; all.length; i += <span class="number">1</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                  all[i].SourceElement().parentNode.className += <span class="string">&#x27; has-jax&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%- theme.mathjax.cdn %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="Add-this-to-config-yml"><a href="#Add-this-to-config-yml" class="headerlink" title="Add this to _config.yml"></a>Add this to <code>_config.yml</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><h4 id="Add-this-to-themes-my-theme-layout-post-ejs"><a href="#Add-this-to-themes-my-theme-layout-post-ejs" class="headerlink" title="Add this to themes/*my_theme*/layout/post.ejs"></a>Add this to <code>themes/*my_theme*/layout/post.ejs</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.mathjax == <span class="literal">true</span>)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(<span class="string">&#x27;mathjax&#x27;</span>) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h4 id="Enable-mathjax-in-post’s-header"><a href="#Enable-mathjax-in-post’s-header" class="headerlink" title="Enable mathjax in post’s header"></a>Enable mathjax in post’s header</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让Hexo Blog支持Mathjax</span><br><span class="line">date: 2022-02-04 17:53:21</span><br><span class="line">tags: [blog]</span><br><span class="line">categories: [notes]</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="Replace-the-renderer"><a href="#Replace-the-renderer" class="headerlink" title="Replace the renderer"></a>Replace the renderer</h4><p>如果之前有安装过<code>hexo-math</code>，还需要先卸载。<br>Hexo 默认的 Markdown 渲染器是<code>hexo-renderer-marked</code>，在解析$\LaTeX$语法的时候会和 Markdown 本身的语法符号冲突。<br>最直接的解决方法是换个渲染器，在这里我选择的是 <a href="https://github.com/sun11/hexo-renderer-kramed">hexo-renderer-kramed</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><script type="math/tex; mode=display">\LaTeX\ is\ supported\ now.</script><blockquote><p>参考文章：<br><a href="https://adores.cc/posts/62947.html">给Hexo主题添加LaTeX公式支持</a></p></blockquote>]]></content>
    
    
    <summary type="html">最近重新搭了一遍博客，使用的主题是Stella，感觉还挺对我审美的。然而这个主题本身不支持Mathjax，所以还得手动改一下。</summary>
    
    
    
    <category term="notes" scheme="https://moe.lovmayoi.top/categories/notes/"/>
    
    
    <category term="blog" scheme="https://moe.lovmayoi.top/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>重启</title>
    <link href="https://moe.lovmayoi.top/2022/01/30/%E9%87%8D%E5%90%AF/"/>
    <id>https://moe.lovmayoi.top/2022/01/30/%E9%87%8D%E5%90%AF/</id>
    <published>2022-01-29T16:06:16.000Z</published>
    <updated>2022-02-04T14:59:06.416Z</updated>
    
    <content type="html"><![CDATA[<p>之后要完善的东西还挺多的，慢慢来吧。很长一段时间没写东西，以后可以多写点（</p>]]></content>
    
    
    <summary type="html">花了半天，姑且是把博客重新搭起来了。</summary>
    
    
    
    <category term="gossip" scheme="https://moe.lovmayoi.top/categories/gossip/"/>
    
    
    <category term="blog" scheme="https://moe.lovmayoi.top/tags/blog/"/>
    
  </entry>
  
</feed>
